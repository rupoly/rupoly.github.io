[{"title":"JS高级","url":"/2022/11/17/vue%E5%B0%8F%E7%AC%94%E8%AE%B0/","content":"JS高级🦁 Day1\n原型的五条规则\n 所有的引用类型(对象 数组 函数),都具有对象的特性,可以自由扩展属性\n所有的对象，都有一个__proto__属性，属性值是一个普通的对象 [[prototype]] __proto__也叫隐式原型\n所有的函数,都有一个prototype属性,属性值也是一个普通的对象(这个属性值是一个指针，指向原型对象) prototype也叫显式原型\n所有对象的隐式原型__proto__，指向它构造函数的prototype显式原型\n当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，就会去它的__proto__中寻找\n\n\n作用域  作用域 Scope： 变量和函数的可访问范围。  作用域控制着变量和函数的可见性 和 生命周期。\n\n全局作用域\n\n  直接写在script或者JS代码（单独的JS文件），属于全局作用域  可见性： 全局作用域中声明的变量，在代码的任何地方都可以访问  生命周期：伴随着页面的生命周期（页面关闭，销毁）  const num = 10function fn() &#123;    // 函数内部    console.log(num)&#125;fn()\n  函数内部，如果不使用任何关键字声明变量，那么这个变量会变成window的属性  function bar() &#123;    abc = 100&#125;bar()console.log(abc)\n\n函数作用域（局部作用域）\n\n  在函数内部申明的变量只能在函数内部访问,外部无法访问  可见性：函数外部不能访问函数内部的变量  生命周期：变量在函数调用执行后，就会销毁（清空/回收）  function foo() &#123;    const abc = 666    console.log(abc)&#125;foo()\n3.块级作用域（ES6新增）  var temp = new Date()function fn() &#123;    console.log(temp)    if (false) &#123; // if是语句        var temp = &#x27;hello world&#x27;    &#125;&#125;fn() 输出结果是undefined\n\nvar 声明的变量会提升到当前作用域的最前面\nif是语句，不是函数，var声明变量不能形成作用域\nvar 声明的变量，只声明，不赋值，默认是undefined\n\n  总结：  if / for 不是函数，他们是语句，用var声明的变量，不能形成作用域  特点：\n只有let/const会产生块级作用域&#123;&#125;\n块级作用域的外部不能访问内部的变量\n两个块级作用域中的变量相互不影响\nif/for是语句,但是用let/const声明的变量,会在内部形成块级作用域\n\n  🤨为什么需要块级作用域?\n内层变量可能覆盖外层变量\n用来技术的循环变量i，会泄露为全局变量\n\n\n\n\n作用域链  // 全局作用域let a = 1let b = 1function f() &#123;    // 局部作用域    let a = 1    function g() &#123;        // 局部作用域        a = 2        console.log(a)    &#125;    g() // 调用g&#125;f() // 调用f\n  🤨什么是作用域链？  函数是可以嵌套函数的，每个函数都有一个局部作用域，这样子，也会形成作用域的嵌套  当访问内层作用域中的某个变量的时候，首先在当前作用域中查找这个变量，如果不存在，往上层查找，直到全局作用域  作用域链的本质: 底层变量的查找机制  查找规则:\n优先在当前作用域中查找变量\n如果不存在,往上层作用域中查找变量,直到全局作用域\n\n\nvar/let/const的区别\nlet / const 可以形成块级作用域\nlet / const 不存在变量提升\nlet / const 不允许重复声明\nlet / const 存在暂时性死区(tamporal dead zone) TDZ，不能在声明之前使用\n浏览器中，var声明的全局变量会挂载到window对象上\n\n  关于const关键字：\nconst一旦声明,必须马上赋值\nconst声明的变量不能改变值(简单类型不能改变值,引用类型不能改变地址)\n\n  // **给五个按钮分别绑定点击事件**const btns = document.querySelectorAll(&#x27;button&#x27;)for(var i = 0; i &lt; btns.length; i++)&#123;    btns[i].addEventListener(&#x27;click&#x27;, function()&#123;        console.log(i)    &#125;)&#125;// 这个用var声明的for循环不管点击哪个按钮，输出的结果都为5for (let i = 0; i &lt; btns.length; i++) &#123;    btns[i].addEventListener(&#x27;click&#x27;, function () &#123;        console.log(i)    &#125;)&#125;// 用let声明的i变量，形成块级作用域，这个循环的i变量，和函数内部的i变量做了一个绑定\n\n垃圾回收机制  🤨什么是垃圾回收机制?  垃圾回收机制(garbage collection) 简称GC  JS中内存的分配和回收是自动完成的，内存在不使用的时候会被JS引擎/垃圾回收程序自动回收\n垃圾回收策略\n引用计数法 （淘汰）\n跟踪记录每个值被引用的次数\n如果这个值被引用了一次，那么就记录次数1\n多次引用会累加\n如果减少一个引用就减少1\n如果引用次数是0，则释放内存\n\n\n引用计数法并不是周期性的垃圾回收，什么时候引用次数为0了，直接回收\n\n引用计数法缺陷:循环引用\n\n循环引用的时候,堆内存空间中创建的对象相互引用,计数永远不会为0\n\n这个对象会一直占用着内存空间,造成内存泄露\n\n  function problem() &#123;    // oA = new Object()    let oA = &#123;&#125;    let oB = &#123;&#125;    oA.c = oB //  oB被oA引用    oB.d = oA //  oA又被oB引用    // 你中有我，我中有你  ---- 代涛语录&#125;problem()\n\n标记清除法（主流）\n\n  主要将GC的过程分为两个阶段：\n标记阶段：标记空间中的活动对象和非活动对象\n清除阶段：回收非活动对象，也就是销毁非活动对象\n\n\n  标记阶段从一组根元素开始，递归遍历（一层一层的）这组根元素，在这个遍历过程中，能访问到的元素称为活动对象，不能访问到的可以判断为垃圾数据。  缺陷：内存碎片化  改进：标记整理算法（Mark-Compact）\n标记空间中活动对象和非活动对象\n回收非活动对象所占用的内存\n内存整理\n\n\n\n  🤨什么是内存泄露呢?  内存泄露: 不再使用的内存，没有及时释放掉\n闭包  🤨什么是闭包? closure  定义: 内层函数引用外层函数的变量的集合  闭包 = 内层函数 + 外层函数的变  条件:\n首先要有内层函数\n内层函数使用了外层函数的变量\n\n\n闭包的作用(特性):\n让外部可以访问函数内部的变量\n\n  function outer1() &#123;    let a = 11    return function () &#123;        console.log(a)    &#125;&#125;const fn = outer1()fn()// 我们在外部调用fun的时候，相当于执行上面注释的函数,执行到log（a）,找的是outer函数内部的变量a\n\n实现数据的私有化，但是我们可以在外层访问\n\n  function count() &#123;    let i = 0    return function () &#123;        i++        console.log(`调用了$&#123;i&#125;次`)    &#125;&#125;const fn = count()fn()\n\n  闭包会产生的问题：内存泄露  本来，我们调用fn()后，按理说， i是函数count里面的变量，局部变量，执行完后应该销毁，但是现在，因为 i 变量和内部的函数function形成了闭包。i变量没有被销毁，所以，造成了内存泄漏。  闭包的实际应用：\n节流 throttle 减少事件执行的频率\n防抖 debounce 你先抖动着,什么时候停了,我再执行事件\n\n\narguments对象\n除箭头函数以外,所有的函数都内置了(默认就存在,自带的) 一个arguments对象\narguments 伪/类数组 有length，有索引，没有push，pop等数组方法\narguments对象,只存在于函数中\n\n  function getSum() &#123;    let sum = 0    for (let i = 0; i &lt; arguments.length; i++) &#123;        sum += arguments[i]    &#125;    return sum&#125;const res = getSum(2, 3, 5, 6, 8)console.log(res)\n\n剩余参数 rest  形式：  …变量名  变量名是自定义的\n剩余参数rest 是一个真数组，存了剩余的实参\n只能放到参数的最后一位\n\n  function getSum(a, b, ...arr) &#123;    console.log(arr)&#125;getSum(1, 2, 3, 4, 5)// 求所有传入参数的和const getSum = (...args) =&gt; &#123;    let sum = 0    args.forEach(el =&gt; sum += el)    return sum&#125;const res = getSum(1, 2, 3)console.log(res)\n\n扩展运算符 spread  扩展运算符(spread)是三个点(…)，它好比 rest 参数的逆运算  作用： 将一个数组转为用逗号分隔的参数序列 （不会改变原数组）\n主要应用：\n求一个数组的最大最小值\n\n  const arr = [11, 1, 6, 9, 77]console.log(Math.max(...arr2))console.log(Math.min(...arr2))\n\n复制/拷贝数组 (浅拷贝)\n\n  const a3 = [5, 6, 7]const a4 = [...a3] // ==&gt; [5, 6, 7]a3[0] = 9console.log(a4) // [5, 6, 7]// ==&gt; 数组里面的元素是基本数组类型， 修改数组元素的值，相互不影响\n\n合并数组\n\n  const a5 = [&#x27;c&#x27;, &#x27;d&#x27;]const a6 = [&#x27;e&#x27;, &#x27;f&#x27;]const a7 = [...a5, ...a6]console.log(a7)  // [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]\n\n扩展运算符还可以展开字符串\n\n  // [...str] ==&gt; 将字符串展开为数组const str = &#x27;hello world&#x27;const a8 = [...arr]console.log(a8)// 反转字符串const res = str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)// 扩展运算符的方式const resStr = [...str].reverse().join(&#x27;&#x27;) // ===&gt; JS高级学的,高级一点console.log(resStr)\n\n将伪数组转为真数组\n\n  const divs = document.querySelectorAll(&#x27;div&#x27;)const resDiv = [...divs]console.log(resDiv)resDiv.push(666) // 转换为真数组后，可以使用数组方法console.log(resDiv)\n  扩展：将伪数组转为真数组的两种方法  // 1. [...likeArr] 使用扩展运算符// 2. Array.from(likeArr)const resReal = Array.from(divs)console.log(resReal)\n\n\n\n\n🦁 Day2\n数组的解构  ES6 允许按照一定的模式， 从数组和对象中提取值，对变量进行赋值。这被称为解构赋值  let [a, b, c] = [1, 2, 3]console.log(a, b, c)\n  从右侧数组中提取值，按照对应的位置，对左侧变量赋值。 注意：数组的解构有顺序。  数组的解构赋值，可以用于交换两个变量  let g = 1let h = 2;[h, g] = [g, h] // 注意分号console.log(g, h)\n\n数组解构的细节\n左边变量多，数组元素少\n\n  const [a, b, c, d] = [1, 2, 3]console.log(a, b, c, d) // d ==&gt; undefined\n\n变量少，数组元素多，可以利用剩余参数接收多余的数组元素\n\n  const [g, h, ...i] = [1, 2, 3, 4, 5, 6]console.log(g, h, i)\n\n数组的解构，按着对应的位置赋值\n\n  const [j, k, , l] = [1, 2, 3, 4]console.log(j, k, l)\n\n解构赋值，还可以设置默认值\n\n  const [m = 0, n = 1] = [66, 77]console.log(m, n)// 默认值什么时候生效?// eg.1 数组对应的值不存在的时候const [o = 0, p = 1] = []console.log(o, p) // 0,1// eg.2 严格等于undefined的时候，默认值生效const [aa = 0, bb = 1] = [&#x27;undefined&#x27;, undefined]console.log(aa, bb) // undefined,1\n\n如果等号右边不是数组，那么会报错\n\n  let [f1] = 1\n\n  多维数组的解构：  // 多维数组： 数组嵌套数组const arr = [1, 2, [3, 4]] // 二维数组console.log(arr[0])console.log(arr[1])console.log(arr[2]) //[3, 4]console.log(arr[2][0])console.log(arr[2][1])// 多维数组的结构// 数组的结构是一种模式匹配，左侧和右侧的模式一样const [a, b, [c, d]] = arr // [1, 2, [3, 4]]console.log(a, b, c, d)\n  本质上，解构的语法属于模式匹配，只要等号两边的模式相同（长得一样），就可以把右边的值，赋值给左边对应的变量\n对象的解构\n对象的解构，是按照属性名解构，可以交换位置\n\n  const &#123;name,age&#125; = objconsole.log(name,age)\n\n要求变量名必须和属性名一致才可以解构出对象中的属性值\n\n  const &#123;username,age&#125; = objconsole.log(username,age) // undefined 18\n\n解构某一个属性名\n\n  const &#123;age&#125; = objconsole.log(age)\n  解构时，对象的变量名也可以重命名，语法：（旧变量名: 新变量名）  对象解构的内部机制：  1.先找到同名的属性，然后再赋值给对应的变量  2.如果有冒号重命名的，被赋值的是冒号后面的那个新变量名  多级对象解构  每当有一个冒号出现，冒号的左边就是查找对应位置，冒号的右边就是赋值的目标  const pig = &#123; name: &#x27;佩奇&#x27;,family: &#123;mother: &#x27;猪妈妈&#x27;,father: &#x27;猪爸爸&#x27;,sister: &#x27;乔治&#x27;&#125;,age: 6&#125;const &#123;name,family: &#123;mother,father,sister&#125;&#125; = pigconsole.log(name, mother, father, sister\n\n函数参数的解构\n函数参数的解构\n\n  const pos = &#123;x:10, y:20&#125;function move(pos)&#123;    console.log(pos)    const &#123;x, y&#125; = pos&#125;move(pos)\n\n可以在形参的位置，直接解构，也可以重新命名如果放在形参上解构，相当于是let声明的变量， 可以修改\n\n\n\n  const pos = &#123;x:10, y:20&#125;function move(&#123;x, y&#125;)&#123;    // console.log(pos)    // const &#123;x, y&#125; = pos    x = 666    console.log(x, y)&#125;move(pos)\n\n如果函数的参数是数组的情况\n\n  function add([x, y]) &#123;    return x + y&#125;const res = add([1, 2])console.log(res)\n\narray.filter() 数组的筛选  filter筛选，过滤的意思  作用：  创建一个新的数组，新数组的元素是通过筛选后的元素 （满足筛选的条件）  参数：  array.filter 接收一个函数， 函数接收两个参数  第一个参数 正在处理的元素  第二个参数 index 索引号 （可选）  返回值：   由满足条件的元素，组成的新数组  注意：  这个函数里面一般要写return，看是否满足条件 返回 true / false  const arr = [10, 20, 30, 40]const res = arr.filter(function (item) &#123;    return item &gt;= 20&#125;)console.log(res)// 箭头函数形式：const res1 = arr.filter(el =&gt; el &gt;= 30)console.log(res1)// 不会改变原数组console.log(arr)\n\n创建对象的三种方法\n第一种：利用字面量来创建一个对象 {}  const person = &#123;    name: &#x27;张三丰&#x27;,    age: 128,    sayHi: function () &#123;        console.log(&#x27;Hi~~~&#x27;)    &#125;&#125;\n  👉获取对象的属性值 两种方式  1 对象.属性  2 对象[属性]\n第二种：利用new Object()创建对象  const obj = new Object() // 创建了一个空对象console.log(obj)obj.name = &#x27;俊俊&#x27;obj.age = 3obj.dance = function () &#123;    console.log(&#x27;会社会摇&#x27;)&#125;console.log(obj)const p = new Object(&#123;    name: &#x27;霖霖&#x27;,    age: 18&#125;)console.log(p)// const obj = &#123;&#125;  // ==&gt; const obj = new Object()// const arr = []  // ==&gt; const arr = new Array()\n\n第三种：利用构造函数创建对象  构造函数：  function 构造函数名(形参1, 形参2, 形参3) &#123; // 构造函数的形参与对象的普通属性是一般一致的    this.属性名1 = 形参1;    this.属性名2 = 形参2; // 属性的值，一般是通过同名的形参来赋值的    this.属性名3 = 形参3;    this.方法名 = function () &#123;    &#125;;&#125;// 调用const obj = new 构造函数名(实参1， 实参2， 实参3)function Person(name, age, sex) &#123;    this.name = name    this.age = age    this.sex = sex    // 如果对象的方法想传参，这里写    this.sayHi = function (msg) &#123;        console.log(msg)    &#125;    // return &#123;&#125;  这里省略了return&#125;// 调用 ==&gt; newconst p = new Person(&#x27;杰伦&#x27;, 28, &#x27;男&#x27;)console.log(p)console.log(p.name)p.sayHi(&#x27;hello&#x27;)\n\n构造函数，相当于一个模板，可以创建一系列具有相同属性和方法的对象\n通过构造函数创建对象的过程，就叫做实例化 ==&gt; new出一个对象的过程\n创建好的这个对象 ==&gt; 实例 / 实例对象\n\n  注意:  👉 构造函数名字首字母要大写  👉 构造函数里 属性和方法前面必须添加 this  👉 构造函数不需要 return 就可以返回结果  👉 我们调用构造函数 必须使用 new\n\n\n构造函数的执行过程\n创建了一个空对象\n让this指向这个空对象\n执行构造函数里面的代码，给这个空对象添加属性和方法\n返回这个对象(this)\n\n  function Person(name, age, sex) &#123;    // 1. 创建了一个空对象    // const this = &#123;&#125;    // 2. 让this指向这个空对象    // 3. 执行构造函数里面的代码，给这个空对象添加属性和方法    this.name = name    this.age = age    this.sex = sex    this.sayHi = function (msg) &#123;        console.log(msg)    &#125;    // 4. return this 返回这个对象(this)&#125;// 当我们执行new的时候，会去执行构造函数内部的代码const p = new Person(&#x27;俊俊&#x27;, 18, &#x27;female&#x27;)\n\n实例成员与静态成员  function Person(name, age, sex) &#123;    this.name = name    this.age = age    this.sex = sex    this.sayHi = function () &#123;        console.log(&#x27;Nice to meet U :)&#x27;)    &#125;&#125;\n\n实例成员  实例：通过构造函数创建出来的对象，就叫做实例  实例成员：实例对象的属性和方法，通过实例对象去访问，也就是构造函数里面通过this添加的属性和方法  // 实例属性console.log(p.name)// 实例方法p.sayHi()\n\n静态成员  构造函数 也是一个对象，可以自由扩展属性  静态成员：在构造函数本身添加的属性和方法，通过构造函数来访问  // 静态属性Person.demo = &#x27;我是给构造函数添加的静态属性&#x27;// 静态方法Person.sayHello = function () &#123;    console.log(&#x27;Hello&#x27;)&#125;console.dir(Person)// 静态成员通过构造函数来访问console.log(Person.demo)Person.sayHello()\n\n\n基本包装类型  基本数据 Number String Boolean undefined null Symbol BigInt  复杂类型 Object  按理说，对象才有属性和方法 ， 基本数据类型没有  基本包装类型： JS底层，将基本数据类型，包装成了复杂数据类型（对象）  ⇒ 基本数据类型，可以使用相应的属性和方法， 原因是底层做了一些处理，包装成了对象  const num = 10.123// num.toFixed() 保留小数位数，返回值是stringconsole.log(num.toFixed(2))const str = &#x27;hello world&#x27;console.log(str.length)\n\n\n🦁 Day3\nObject静态方法  Object.keys()  // Object.keys(obj) 静态方法// 返回一个对象的所有属性名，得到一个数组const obj = &#123;name:&#x27;俊俊&#x27;, age:18&#125;const res = Object.keys(obj)console.log(res)\n  Object.values()  // 返回一个对象的所有属性值，得到的也是一个数组const res2 = Object.values(obj)console.log(res2)\n  Object.assign()  // 语法：Object.assign(target, ...sources)target : 目标对象 sources: 源对象// 作用： 对象的浅拷贝// 返回值：目标对象。const obj = &#123;&#125; // 目标对象const o = &#123;    name: &#x27;练练&#x27;,    age: 88&#125; // 源对象const res = Object.assign(obj, o)console.log(obj) // 目标对象被修改了// 应用：合并对象const o1 = &#123;a: 1&#125;const o2 = &#123;b: 2&#125;const o3 = &#123;c: 3&#125;const res2 = Object.assign(o1, o2, o3)\n\nArray的一些实例方法\n\nArray.prototype.reduce()\n\n  // 语法：arr.reduce(callbackFn, initialValue)// 作用：对数组里的每个元素都执行一个自定义的reducer函数，将其结果汇总为单个返回值// 参数：//      callbackFn               :  回调函数   必须     √//      initialValue             :  初始值     （可选）  √// callbackFn的参数：    //       previousValue      :  上一次调用callbackFn的返回值    √//       currentValue       :  当前元素                      √//       currentIndex       :  当前元素的索引  （可选）//       array              :  源数组  （可选）// 返回值： 使用reducer回调函数遍历整个数组后的结果// 注意： 如果有初始值，那么prev第一次执行的时候，就是写的初始值，如果没有初始值，initValue就是数组的第一个元素 arr[0], cur就依次取第二个元素const arr = [1, 2, 3]const res = arr.reduce(function (pre, cur) &#123;    return pre + cur&#125;, 0)console.log(res)// 作用： 常用于数组的求和const res2 = arr.reduce((pre, cur) =&gt; pre + cur, 8)console.log(res2)\n2.Array.prototype.find()  // 语法：arr.find(callbackFn)// 作用: 返回数组中满足条件的第一个的元素， 否则返回 undefined// 参数: //    cbFn 函数   ==&gt; 注意，这个回调函数，一般需要写上return//    cbFn的参数//             第一个参数   ： item  当前元素//             第二个参数   ： index  索引  （可选）// 返回值： 数组中第一个满足条件的元素   / undefined// 注意： 返回的是第一个元素const arr = [&#x27;orange&#x27;, &#x27;blue&#x27;, &#x27;red&#x27;]const res = arr.find(function (item) &#123;    return item === &#x27;blue&#x27;&#125;)console.log(res)const res2 = arr.find(el =&gt; el === &#x27;blue&#x27;)// 实际应用 可以搜索查找// 需求： 找到数组中名字为小米的那个元素？const arrTemp = [&#123;name: &#x27;小米&#x27;,price: 1999&#125;, &#123;name: &#x27;华为&#x27;,price: 3999&#125;, &#123;name: &#x27;Apple&#x27;,price: 8999&#125;]const mi = arrTemp.find(el =&gt; el.name === &#x27;小米&#x27;)const mi2 = arrTemp.find((&#123;name&#125;) =&gt; name === &#x27;小米&#x27;)\n\n3.Array.prototype.findIndex()  // 语法：arr.findIndex(cbFn)// 作用：查找数组中满足条件的第一个元素，如果满足条件，返回索引，如没没有返回-1// 参数：  cbFn//    cbFn: //      第一个参数： item  当前数组//      第二个参数： index 索引 （可选）// 返回值： 索引号/ -1 const arrTemp = [&#123;name:&#x27;小米&#x27;, price:1999&#125;, &#123;name:&#x27;华为&#x27;, price: 3999&#125;, &#123;name:&#x27;Apple&#x27;, price:8999&#125;]const index = arrTemp.findIndex(el =&gt; el.price === 3999)console.log(index)\n\n4.Array.prototype.every()  // 语法：arr.every(cbFn)// 作用：检测数组内的所有元素是否都满足指定的条件，如果都满足，返回true  , 否则false// 参数：  cbFn     ===&gt; return //    cbFn: //      第一个参数： item  当前数组//      第二个参数： index 索引 （可选）// 返回值： boolean     true / false// 注意： cbFn 要写returnconst arr = [10, 20, 30]const resBool = arr.every(function (item) &#123;    return item &gt;= 10&#125;)console.log(resBool)\n\n5.Array.prototype.some()  // arr.some(cbFn)// 作用： 检测数组中的元素是否满足指定的条件，只要有一个满足，就返回true 、 否则falseconst resSome = arr.some(el =&gt; el &gt;= 30)console.log(resSome)\n\n6.Array.prototype.includes()  // arr.includes()// 作用： 判断数组中是否包含某个元素，如果有， true， 否则falseconst resIn = arr.includes(10)console.log(resIn)\n\n7.Array.prototype.join()  // arr.join(&#x27;分隔符&#x27;)// 作用：将数组转为字符串const arr = [2022, 10, 30]const res = arr.join(&#x27;-&#x27;)console.log(res)\n\n\nString的一些实例方法\n1.String.prototype.split()  // str.split(分隔符)// 作用： 使用指定的分隔符，将字符串分割，得到一个字符串数组const str = &#x27;Hello-world-JS&#x27;const words = str.split(&#x27;-&#x27;)console.log(words)\n\n2.String.prototype.substring()  // str.substring(开始索引号[, 结束的索引号]) // 语法：str.substring(indexStart[, indexEnd])// 作用：从字符串中截取某一个子段出来// 注意：//   1. 如果省略indexEnd，取到最后 //   2. [start, end) 前闭后开区间，结束索引号不包含在截取的字符串内const str2 = &#x27;大家现在饿了么？&#x27;console.log(str2.substring(2))console.log(str2.substring(2,4))\n\n3.String.prototype.startsWith()  // str.startsWith()// 语法：startsWith(searchString, position)// 作用：判断是否以某个字符串开头// searchString:  要搜索的字符串// position    :  在str中开始搜索的位置，默认为0  可选// 返回值  true / falseconst str = &quot;To be, or not to be, that is the question.&quot;;console.log(str.startsWith(&quot;To be&quot;)); // trueconsole.log(str.startsWith(&quot;not to be&quot;)); // falseconsole.log(str.startsWith(&quot;not to be&quot;, 10)); // true\n\n4.String.prototype.includes()  // str.includes(substr[, pos])// 作用：判断一个字符串是否包含另一个子串   true / falseconst str2 = &quot;To be, or not to be, that is the question.&quot;;console.log(str2.includes(&#x27;not to be&#x27;))\n\n\nNumber.prototype.toFixed()  // 保留小数位数，四舍五入// num.toFixed()const num = 10.923console.log(num.toFixed(1))const num1 = 10console.log(num1.toFixed(2))// 传参数，也会四舍五入， 注意 返回值是字符串！！！！// 如果不传参数,四舍五入转为整数console.log(num.toFixed())\n\n\n🦁 Day4\n原型prototype  构造函数会存在浪费内存的问题  function Star(name, age) &#123;    this.name = name    this.age = age    this.sing = function () &#123;        console.log(&#x27;唱歌&#x27;)    &#125;&#125;const kk = new Star(&#x27;坤坤&#x27;, 18)const jl = new Star(&#x27;杰伦&#x27;, 20)// console.log(kk, jl)console.log(kk.sing === jl.sing) // false  表示内存中sing的地址不相等kk.sing()\n  每创建一个对象，都会在堆内存空间中新开辟一个空间来存储方法，  所以，就引入原型对象来解决该问题：  function Star(name, age) &#123;    // 1. 公共的属性写到构造函数里面    this.name = name    this.age = age&#125;// 2. 公共的方法写到原型对象上  节约了内存Star.prototype.sing = function () &#123;    console.log(&#x27;唱歌&#x27;)&#125;const kk = new Star(&#x27;坤坤&#x27;, 18)const jl = new Star(&#x27;杰伦&#x27;, 20)kk.sing()jl.sing()// sing是公共的方法，在内存中地址是相同的console.log(kk.sing === jl.sing) // true// 以后一般情况下：// 1. 公共的属性写到构造函数里面// 2. 公共的方法放到原型对象上！！！\n  JS原型： 原型就是一个对象，也叫原型对象\n所有的函数，都有一个prototype属性(显式原型)，这个属性是一个指针，指向原型对象\n原型上默认有一个叫做constructor的属性，指向这个构造函数本身\n我们可以往这个原型对象中添加属性和方法\n\n\n构造函数和原型方法中的this\n构造函数里面的this指向是实例对象\n原型方法中的this指向的还是实例对象\n\n  let that = null // 全局变量function Star(name, age) &#123;    this.name = name    this.age = age    console.log(this) // ?  执行完构造函数this就被释放掉了    that = this // that把this的指向/状态 保存起来了 &#125;// 这里，我们声明了一个全局变量that，在调用new的时候，保存this的状态，调用结束后，// 如果that还是指向的构造函数创建的实例，说明我们的结论没问题Star.prototype.sing = function () &#123;    console.log(&#x27;唱歌&#x27;)&#125;// 1. 构造函数里面的this指向是实例对象const ll = new Star(&#x27;霖霖&#x27;, 18)ll.sing()console.log(that)// 2. 原型方法中的this指向的还是实例对象\n\nconstructor  constructor属性：  function Star(name, age) &#123;    this.name = name    this.age = age&#125;const ll = new Star(&#x27;磊磊&#x27;, 28)// constructor console.dir(Star)// 首先，constructor在原型上// 1. 每个原型上都默认有一个constructor属性，指回构造函数本身。// 表示我，我这个原型，是哪个构造函数的原型。其实就相当于是一个标志。Star.prototype.constructor === Star // 理解记忆！！// 2. 所有对象的隐式原型，指向构造函数的显式原型console.log(ll.__proto__ === Star.prototype) // true// 3. ll.__proto__ ==&gt; 指向的也是原型对象console.log(ll.__proto__.constructor === Star) // 理解记忆\n  constructor应用：  // 每个原型对象中都有一个constructor属性，指回构造函数本身function Star(name, age) &#123;    this.name = name    this.age = age&#125;// Star.prototype.sing = function()&#123;//     console.log(&#x27;唱歌&#x27;)// &#125;// Star.prototype.dance = function()&#123;//     console.log(&#x27;dance&#x27;)// &#125;// Star.prototype.rap = function()&#123;//     console.log(&#x27;rap&#x27;)// &#125;// 1. 上述的方式给原型添加公共方法，不会修改原型。// 我们如果直接给Star.prototype赋值一个对象，这个时候，原型上的默认属性construct// 我们可以手动给这个对象添加constructor属性，指回这个构造函数// 2. 这种以对象赋值的方式，会覆盖掉原型。 需要我们手动添加一个constructor属性Star.prototype = &#123;    constructor: Star, // 指回构造函数    sing: function () &#123;        console.log(&#x27;唱歌&#x27;)    &#125;,    dance: function () &#123;        console.log(&#x27;dance&#x27;)    &#125;,    rap: function () &#123;        console.log(&#x27;rap&#x27;)    &#125;&#125;const ldh = new Star(&#x27;刘德华&#x27;, 18)ldh.__proto__ === Star.prototype // ==&gt; 原型对象console.log(ldh)ldh.sing()ldh.dance()\n\n__proto__隐式原型\n所有的对象，都有一个__proto__属性(隐式原型)，属性值也是一个对象(其实就是指向的原型对象)\n__proto__隐式原型，实例通过__proto__访问(链接)到了它的原型对象，__proto__相当于一个桥梁，链接， 实例就通过__proto__访问到原型对象。\n\n  console.log(ldh.__proto__ === Star.prototype) // true/*==================================  eg  ====================================*/function Animal() &#123;    this.color = &#x27;orange&#x27;&#125;const cat = new Animal()console.log(cat)console.log(cat.__proto__ === Animal.prototype)console.log(Animal.prototype.constructor === Animal)console.log(cat.__proto__.constructor === Animal)// 1. &#x27;实例对象.__proto__ === 构造函数.prototype&#x27; ==&gt; 原型// 2. __proto__ 表示了实例和原型之间的一个关系，相当于就是一个桥梁，实例通过它访问原型\n\n构造函数-实例-原型对象之间的关系  // 四条线： // 1. 构造函数.prototype ===&gt;  原型对象// 2. 原型对象.constructor ===&gt; 构造函数// 3. 实例对象.__proto__  ===&gt; 原型对象// 4. 构造函数 new ，创建出 实例对象// 高程四 第八章 P250 : 实例与构造函数原型之间有直接的联系（__proto__），但实例与构造函数之间没有直接联系\n  \n原型链\n每个对象通过__proto__属性访问到它的原型(对象)，原型对象也有它的原型对象\n当访问一个对象的属性或方法的时候，先在自身中寻找\n如果没有，就沿着__proto__这条链上查找，直到最顶层Object.prototype为止\n\n  （Object.prototype.proto === null）  function Person(name) &#123;    this.name = name&#125;const person = new Person()// 原型链：// ==&gt; 规则2 所有的对象都有一个__proto__，属性值也是一个对象// 1. Person.prototype也是一个对象，所以，它也有__proto__属性，属性值也是对象。// console.dir(Person)console.log(Person.prototype.__proto__) // ===&gt; __proto__访问到原型// ==&gt; 原型上默认有一个constructor属性，指回构造函数// ==&gt; 规则4 所有对象的隐式原型指向它的构造函数的显式原型// Person.prototypePerson.prototype.__proto__ === Object.prototype// person.__proto__ === Person.prototype// Person.prototype 这个原型对象  是 Object这个构造函数创建的// 2. Object 它是一个构造函数// Object.prototype ==&gt; 得到的也是一个原型// Pbject.prototype这个原型上默认有一个constructor属性，指向构造函数本身Object.prototype.constructor === Object// Object.prototype              ===&gt; 原型// Person.prototype.__proto__    ===&gt; 原型console.log(Person.prototype.__proto__)console.log(Object.prototype)// 也就是，上面这两个  指向的  都是Object这个函数的原型console.log(Person.prototype.__proto__ === Object.prototype)// 我们说的原型,可以说是构造函数的原型,也可以说实例的原型,指的都是同一个// 构造函数 通过 prototype 访问到它的原型// 实例    通过 __proto__ 访问到它的原型// 3. Object.prototype// Object.prototype 它也是一个原型对象, 所以 它也有__proto__属性 console.log(Object.prototype)console.log(Object.prototype.__proto__ === null)// 正常的原型链终止到Object.prototype,  也就是Object.prototype.__proto__ === null\n  // 数组的原型链const arr = [1, 2, 3]// 数组也是一个对象// arr --&gt; Array.prototype --&gt; Object.prototype --&gt; nullconsole.log(Array.prototype)// 函数的原型链const fn = function () &#123;&#125;// fn --&gt; Function.prototype --&gt; Object.prototype --&gt; null// 原型链靠的是__proto__ 链接的// JS中一切皆对象， ==&gt; Object 创建的\n\n\n🦁 Day5\ninstanceof  用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上  (用于检测A这个实例(对象)是不是B这个构造函数创建的，或者是不是B这个祖先构造函数创建的)  // 定义构造函数function C()&#123;&#125;function D()&#123;&#125;const obj = new C()console.log(obj instanceof C) // trueconsole.log(obj instanceof D) // falseconsole.log(obj instanceof Object) // trueconst arr = [1, 2, 3]console.log(arr instanceof Array) // trueconsole.log(arr instanceof Object) // trueconsole.log(arr instanceof Function) // false\n\n箭头函数\n箭头函数没有prototype ,原型\n不能使用new调用箭头函数，也就是它不能作为构造函数\n箭头函数没有arguments对象，可以利用rest接收剩余参数\n箭头函数本身没有this，箭头函数的this在定义的时候就确定了，指向的是上层作用域中的this\n\n\n实现继承的方式\n原型链继承 // 继承： 子类拥有(访问到)父类的属性和方法// 通过构造函数创建的实例，可以共享原型上的属性和方法// 父类function Parent(name) &#123;    this.name = name || &#x27;父类&#x27;    this.arr = [1, 2, 3] // (强调私有)&#125;Parent.prototype.say = function () &#123;    console.log(&#x27;hello&#x27;)&#125;// 子类 function Child(hobby) &#123;     this.hobby = hobby &#125;// ==&gt; 让子类的原型等于父类的实例，让原型链接起来 Child.prototype = new Parent() // 因为new Parent() 相当于覆盖了Child.prototype的本身的原型对象 // 所以，这里我们应该指回本身的构造函数 Child.prototype.constructor = Child // (是不是原型链继承，和这句话没关系) boy1.__proto__ = Child.prototype Child.prototype.__proto__ = Parent.prototype const boy1 = new Child(&#x27;music&#x27;) const boy2 = new Child(&#x27;dance&#x27;) console.log(boy1) console.log(boy2) // 需求，想要boy1能访问到Parent上的name arr这些属性 // 如果Parent它的原型在子类的原型链上，这个实例就能访问到Parent的属性和方法// 1. 优点：属性共享方法复用// 实例共享了父类的原型上的方法boy1.say()boy2.say()console.log(boy1.say === boy2.say) // true// 2. 缺点：// 2.1 子类实例化的时候，不能给父类构造函数传参console.log(boy1.name, boy2.name)// 2.2 子类实例共享了父类的引用属性，比如arr属性//     实例修改了这个属性值后，会相互影响console.log(boy1.arr)boy1.arr.push(666)console.log(boy1.arr) // [1, 2, 3, 666]console.log(boy2.arr) // [1, 2, 3, 666]\n\n借用构造函数\n组合继承\n原型式继承\n寄生式继承\n寄生式组合继承 ==&gt; 最完美的！\nES6 ===&gt; extends (语法糖 底层实现就是寄生式组合继承)\n\n\n赋值  赋值：将某一个数值或对象赋给某个变量的过程\n基本数据类型：值传递，赋值后两个变量互不影响\n引用类型：会互相影响，赋值不是浅拷贝，没有堆内存中新创建一个对象。\n\n\n浅拷贝  浅拷贝： 在堆内存中新开辟一个内存空间，创建一个新对象，拷贝原对象的第一层基本数据类型的值和引用类型的地址。  let obj1 = &#123;    name: &#x27;JS&#x27;,    book: &#123;        title: &#x27;you dont know JS&#x27;,        price: &#x27;169&#x27;    &#125;&#125;\n  实现浅拷贝的几种方式： \nObject.assign(目标对象，源对象)  let obj2 = Object.assign(&#123;&#125;, obj1)// 第一层，属性值如果是基本数据类型，拷贝前后的两个对象的这个属性相互不影响obj2.name = &#x27;Java&#x27;console.log(obj2.name)console.log(obj1.name)// 第一层，属性值如果是引用类型，引用类型的值改变，会相互影响obj1.book.price = 66\n\n扩展运算符 …  const obj3 = &#123;    ...obj1&#125;console.log(obj3)obj3.name = &#x27;test&#x27;console.log(obj1.name)obj3.book.price = 222console.log(obj1.book.price)\n\nArray.prototype.concat()  const arr1 = [1, 2, &#123;user:&#x27;杰伦&#x27;&#125;] const arr2 = arr1.concat() arr1[0] = 666 console.log(arr1) console.log(arr2) arr1[2].user = &#x27;磊磊&#x27; console.log(arr1) console.log(arr2)\n\nArray.prototype.slice()  const arr3 = [1, 2, &#123;user:&#x27;杰伦&#x27;&#125;]const arr4 = arr3.slice()console.log(arr3)console.log(arr4)\n\n\n\n深拷贝  深拷贝： 在堆内存中开辟一个新的空间存新的对象。递归的拷贝原对象的所有属性和方法，拷贝前后的两个对象，互不影响。  实现深拷贝的三种方式：\n1.递归拷贝  const obj = &#123;    name: &#x27;jj&#x27;,    age: 19,    hobby: [&#x27;dance&#x27;, &#x27;sing&#x27;],    family: &#123;        father: &#x27;猪爸爸&#x27;,        mother: &#x27;猪妈妈&#x27;    &#125;&#125;const o = &#123;&#125;const deepClone = (newObj, oldObj) =&gt; &#123;    for (const k in oldObj) &#123;        if (oldObj[k] instanceof Array) &#123;            // hobby = []            newObj[k] = []            // 给这个新对象，添加元素            // deepClone([], [&#x27;dance&#x27;, &#x27;sing&#x27;])            deepClone(newObj[k], oldObj[k])        &#125; else if (oldObj[k] instanceof Object) &#123;            newObj[k] = &#123;&#125;            deepClone(newObj[k], oldObj[k])        &#125; else &#123;            newObj[k] = oldObj[k]        &#125;    &#125;&#125;deepClone(o, obj)// 注意：需要先判断是否为Array，因为Array也属于Object\n\n2.lodash  // 引入lodash文件&lt;script src=&quot;../06-素材/lodash.min.js&quot;&gt;&lt;/script&gt;const obj = &#123;    name: &#x27;jj&#x27;,    age: 19,    hobby: [&#x27;dance&#x27;, &#x27;sing&#x27;],    family: &#123;        father: &#x27;猪爸爸&#x27;,        mother: &#x27;猪妈妈&#x27;    &#125;&#125;// 使用lodash库，实现深拷贝const o = _.cloneDeep(obj)console.log(o)\n\n3.JSON.parse(JSON.stringify())  // JSON.stringify() 将对象转为JSON格式的字符串// JSON.parse() 将JSON格式的字符串转为对象const obj = &#123;    name: &#x27;jj&#x27;,    age: 19,    hobby: [&#x27;dance&#x27;, &#x27;sing&#x27;],    family: &#123;        father: &#x27;猪爸爸&#x27;,        mother: &#x27;猪妈妈&#x27;    &#125;,    test1: function () &#123;&#125;,    test2: undefined,    test3: Symbol(&#x27;id&#x27;),    test4: NaN,    test5: Infinity,    test6: new RegExp(/浅/, &#x27;g&#x27;),    test7: new Date()&#125;const res = JSON.parse(JSON.stringify(obj))console.log(res)// 缺陷：// 1. 如果拷贝对象的属性值是function，undefined，Symbol，这个键值对会丢失// 2. 如果是NaN，Infinity，属性值会变为null// 3. 如果是正则，变为空对象// 4. 如果是new Date()，会变为字符串\n\n\n递归函数  递归： 自己调用自己 有递 有归  function fn(num) &#123;    if (num === 1) &#123;        return 1    &#125;    return num + fn(num - 1)&#125;fn(3) // ==&gt;  3 + fn(2)  ==&gt;  3 + 2 + fn(1) ==&gt; 3 + 2 + 1  ==&gt; 6console.log(fn(3)) // 6fn(5) // ==&gt;  5 + fn(4) ==&gt;  5 + 4 + fn(3) ==&gt; 5 + 4 + 3 + fn(2) ==&gt; 5 + 4 + 3 + 2 + fn(1)//   5 + 4 + 3 + 2 + 1  ==&gt; 15 console.log(fn(5))\n  递归的问题：递归爆栈(栈溢出)  栈 ===&gt; 数据结构， 有先进后出的特征， 栈有深度， 如果超出了，就会造成栈溢出报错（Maximum call stack size exceeded）  let res = fn(100000)console.log(res)// 递归也可以看作一种循环(不断的自己调用自己)，循环有终止条件，当然递归也需要有终止条件// 递归的终止的条件， 一般写在第二次调用的前面，return可以终止函数的执行let i = 1function count() &#123;    i++    console.log(`这是第$&#123;i&#125;次调用`)    if (i === 1000) &#123;        return    &#125;    count()&#125;count()\n\nthis指向与改变this指向的三种方法\nthis指向  // 1. 全局作用域中 / 普通函数中 / 定时器里面  this 指向 window// 1.1 全局作用域console.log(this) // window// 1.2 普通函数调用function fn() &#123;    console.log(&#x27;大家吃早饭了嘛?&#x27;)    console.log(this) // window&#125;fn()// 1.3 定时器里面setTimeout(function () &#123;    console.log(this) // window&#125;, 1000)// 2.1 方法调用中, 谁调用这个方法, this指向谁const obj = &#123;    name: &#x27;小平&#x27;,    age: 18,    sayHi: function () &#123;        console.log(this)    &#125;&#125;obj.sayHi()// 2.2 事件注册的时候, this指向被绑定的元素const btn = document.querySelector(&#x27;button&#x27;)btn.addEventListener(&#x27;click&#x27;, function (e) &#123;    console.log(this) // 绑定事件的元素    console.log(e.target) // 触发事件的元素    console.log(e.currentTarget) // 同this, 绑定事件的元素&#125;)// 3. 构造函数中, this 指向的是 构造函数的实例 function Foo(name, age) &#123;     this.name = name     this.age = age     console.log(this) &#125; const person1 = new Foo(&#x27;小红&#x27;, 19) const person2 = new Foo(&#x27;小白&#x27;, 18)\n\n改变this指向的三种方法\ncall 改变this指向\n\n  // call 改变this指向const obj = &#123;    msg: &#x27;hello&#x27;&#125;const abc = &#123;    demo: &#x27;哈哈哈&#x27;&#125;function fn(x, y) &#123;    console.log(this)    return x + y&#125;const res = fn.call(abc, 1, 2)console.log(res)// fn.call()// 1. 改变this的指向// 2. 会调用函数，立即执行，返回函数调用结果// 3. 注意，第一个参数就是要让this指向哪个对象//    后面紧跟的是参数列表\n\napply 改变this指向\n\n  const obj = &#123;    msg: &#x27;hello&#x27;&#125;const abc = &#123;    demo: &#x27;哈哈哈哈&#x27;&#125;function fn(x, y) &#123;    // console.log(this)    return x + y&#125;// fn(1, 2)// fn.apply(this指向谁， [数组])const res = fn.apply(abc, [1, 2])console.log(res)// fn.apply()// 1. 改变this的指向// 2. 调用函数，立即执行// 3. 返回值就是函数本身的返回值        // 注意：apply的第二个参数是数组\n\nbind改变this指向\n\n  const obj = &#123;    msg: &#x27;hello&#x27;&#125;const abc = &#123;    demo: &#x27;哈哈哈哈&#x27;&#125;function fn(x, y) &#123;    console.log(this)    return x + y&#125;// fn.bind(obj, 参数列表)// 1. 改变this指向// 2. 有返回值，返回值是一个函数// 3. 不会立即执行，需要我们手动调用执行const fun = fn.bind(demo, 1, 2)// const fun = function(x, y)&#123;//     console.log(this)//     return x + y// &#125;// console.log(fun)// 手动再调用一次fun()\n  call apply bind的区别？\n它们都可以改变this指向\ncall和bind接收的是参数列表，apply接收的是数组\ncall和apply会立即执行，bind返回函数，需要手动调用\n\n\n\n\n防抖（debounce）  当持续触发事件时，一定时间段内没有再触发事件，回调函数才会执行一次，如果设定延迟时间到来之前，又触发了事件，就重新计算延时。  &lt;input type=&quot;text&quot;&gt;&lt;script&gt;    const input = document.querySelector(&#x27;input&#x27;)    const sendMsg = function (x, y) &#123;        console.log(x + y)    &#125;    const debounce = (fn, ms = 0) =&gt; &#123;        let timerId\t\t\t\t// 1. return function 外面的代码，绑定keyup事件的时候，就立即执行了\t\t\t\t// 2. return function 里面的代码，触发事件的时候执行        return function (...args) &#123; // 剩余参数            clearTimeout(timerId)            timerId = setTimeout(() =&gt; &#123;\t\t\t\t\t\t\t\t// 箭头函数的this定义的时候就确定了，指向上层，上层指向的是input                fn.call(this, ...args) // spread扩展运算符                // args是一个真数组，apply接收数组，call接收参数列表                // fn.apply(this, args)            &#125;, ms)        &#125;    &#125;    input.addEventListener(&#x27;keyup&#x27;, debounce(sendMsg, 200).bind(input, 1, 2))&lt;/script&gt;\n\n节流（throttle）  持续的触发事件，在一段时间内只允许函数执行一次 ⇒ 减少一段时间内，事件的执行频率  应用场景\n浏览器窗口缩放resize事件\n滚动scroll事件，mousemove事件等\n\n  两种简单节流版本：\n时间戳版\n\n  const box = document.querySelector(&#x27;.box&#x27;)let i = 0const move = function () &#123;    box.innerHTML = i++&#125;const throttle = (fn, ms = 0) =&gt; &#123;    let start = 0    return function (...args) &#123;        let now = +new Date()        // 如果当前时间 - 开始时间 &gt;= 等待时间 再执行函数        if (now - start &gt;= ms) &#123;            fn.call(this, ...args)            start = +new Date() // 将当前时间记录，作为下一个计时的起点        &#125;    &#125;&#125;box.addEventListener(&#x27;mousemove&#x27;, throttle(move, 100))\n\n定时器版\n\n  const box = document.querySelector(&#x27;.box&#x27;)let i = 0const move = function () &#123;    box.innerHTML = i++&#125;const throttle = (fn, ms = 0) =&gt; &#123;    let timerId    return function (...args) &#123;        // 需要，只有一个定时器在等待执行        // 如果没有定时器，就开启一个        if (!timerId) &#123;            timerId = setTimeout(() =&gt; &#123;                fn.call(this, ...args)                timerId = null            &#125;, ms)        &#125;    &#125;&#125;box.addEventListener(&#x27;mousemove&#x27;, throttle(move, 200))\n  当然，lodash也可以实现防抖和节流。\n\n"}]