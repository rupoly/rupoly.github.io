[{"title":"Vue笔记","url":"/2022/11/22/Vue%E7%AC%94%E8%AE%B0/","content":"接近Vue入口文件的特点​    要想要某个页面或文件在项目中生效，一定会直接或间接的与入口文件产生联系\n\n引入vue依赖 =&gt; 如果引入的是第三方依赖，那么路径不必写成相对或绝对路径import Vue from &#x27;vue&#x27;\n引入根组件import App from &#x27;./APP.vue&#x27;\n\nvue项目的一个控制台打印提示，默认关闭Vue.config.productionTip = false\n\n\n实例化vue对象，并且挂载到唯一html页面上new Vue(&#123;  render: h =&gt; h(App), // 渲染函数，告诉vue要渲染的组件&#125;).$mount(&#x27;#app&#x27;) // 确定vue实例挂载的盒子\n\n\n自定义vue中开发服务器配置及关闭eslint检查自定义服务器配置在vue.config.js文件中，moudule.exports添加devServer:&#123;  // 自定义开发服务器配置    prot: 3000 // 自定义端口号&#125;\n全局关闭eslint检查lintOnSave:false // \n局部关闭eslint检查​    直接添加//注释即可\n// 只能忽略下一行代码的eslint检测：// eslint-disable-next-linelet a = 10// 只能忽略当前行代码的eslint检测：let b = 20// eslint-disable-line// 忽略后续代码的eslint检测：/* eslint-disable *//* eslint-disable */let c = 30 let d = 40let e = 50// 开启后续代码的eslint检测：/* eslint-enable *//* eslint-enable */let f = 60\n\n关于.vue文件中的三个标签\ntemplate标签标签模板 =&gt; 对应记忆对照html文件中的&lt;html&gt;标签结构vue模板标签中，只能有一个根标签!\nscript标签// js相关的代码// 在js中 有一个 export default &#123;&#125; 结构， 在这个结构中需要遵循vue的代码规则\nstyle标签/* 当前组件样式表 - 期望每个组件中的style 标签只能影响当前组件中的标签内容 *//* 只需要在style 标签中添加一个属性 - scoped 就可以让样式只作用于当前组件的标签 *//* 原理: scoped 属性，会为每一个样式表自动添加当前组件中所被设置的自定义属性（data-v-hash随机数），形成一个复合选择器，而能够被选中的标签均存在于当前组件中，所以可以被区分开 *//* 规律/要求: 只要组件需要设置style样式，就在style标签中添加 scoped 属性 */\n\nMVVM模型的理解​    设计模式: 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。\n\nMVVM，一种软件架构模式，决定了写代码的思想和层次\nM：   model数据模型          (data里定义)    \nV：    view视图                   （html页面）\nVM： ViewModel视图模型  (vue.js源码)\n\n\n\n\nMVVM通过数据双向绑定让数据自动地双向同步  不再需要操作DOM\nV（修改视图） -&gt; M（数据自动同步）\nM（修改数据） -&gt; V（视图自动同步）\n\n\n\n\n总结：\n​        vue使用的mvvm设计模式。MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。\n在MVVM模型之前使用的MVC模型：\n\n​        MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。\n原生的HTML + JS就是使用的这个模型\n\n将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。\n\n\n\n\n\n\n关于Vue中的属性V-bind动态属性详解语法： v-bind:属性名=”vue中定义的变量/表达式”\n简化的语法： 将v-bind:属性名 转化为 =&gt; :属性名\n&lt;a v-bind:href=&quot;baiduUrl&quot;&gt;&#123;&#123; url &#125;&#125;&lt;/a&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            baiduUrl:&#x27;http://www.baidu.com&#x27;,            url:&#x27;www.baidu.com&#x27;,        &#125;    &#125;&#125;\n\n注意点：\n关于v-bind动态属性作用于图片时尤其需要注意：v-bind 会直接把资源路径认定为字符串\n解决方式：直接在v-bind动态属性后面传递实际的资源\n方法1：通过import引入资源文件，在data中进行定义，最后在动态属性中使用\n&lt;img v-bind:src=&quot;img1&quot; alt=&quot;&quot;&gt;\n\n// 引入importimport img from &#x27;../assets/logo.png&#x27;export default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 在data中设置路径，引入            img1:img,        &#125;    &#125;&#125;\n\n方法2：通过require 引入资源文件，直接在动态属性中使用\n&lt;img v-bind:src=&quot;img2&quot; alt=&quot;&quot;&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 通过require 引入资源文件，直接在动态属性中使用            img2:require(&#x27;../assets/logo.png&#x27;)        &#125;    &#125;&#125;\n\n开发中一般会使用方法2，优势： require引入资源的方式是按需的，这样一来，页面初始更新效率会更高\nv-on事件绑定语法：\nv-on:事件名=&quot;简单的函数执行体&quot; =&gt; 只有一行代码v-on:事件名=&quot;methods中定义的方法&quot;v-on:事件名=&quot;methods中定义的方法(实际参数)&quot;简写: v-on: =&gt; @     @事件名=&quot;methods中定义的方法&quot;\n\n使用：\n&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count++&quot;&gt;点我加1&lt;/button&gt;&lt;button v-on:click=&quot;addCount2&quot;&gt;点我加2并打印&lt;/button&gt;&lt;button @click=&quot;addCountN(7)&quot;&gt;点我加7&lt;/button&gt;\n\nexport default &#123;  name: &quot;DemoIndex03&quot;,  data() &#123;    return &#123;      count: 0,    &#125;;  &#125;,  // vue组件的方法定义在methods对象中  methods: &#123;    // 点击加2并打印    addCount2() &#123;      this.count += 2;      console.log(this.count);    &#125;,    // 点击加按钮传递过来的数字    addCountN(num) &#123;      this.count += num;    &#125;,  &#125;,&#125;;\n\nv-on获取事件对象\nvue事件处理函数中, 拿到事件对象\n\n语法:\n\n无传参, 通过形参直接接收\n传参, 通过$event指代事件对象传给事件处理函数\n\n&lt;template&gt;&lt;div&gt;    &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;hr /&gt;    &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/a&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            // 1. 事件触发, 无传值, 可以直接获取事件对象是            one(e)&#123;                console.log(e)                e.preventDefault()            &#125;,            // 2. 事件触发, 传值, 需要手动传入$event            two(num, e)&#123;                console.log(e)                e.preventDefault()            &#125;        &#125;    &#125;;&lt;/script&gt;\n\n如何不用e这个事件对象而阻止默认行为呢？↓  事件修饰符\nv-on修饰符语法:\n\n@事件名.修饰符=”methods里函数”\n.stop - 阻止事件冒泡\n.prevent - 阻止默认行为\n.once - 程序运行期间, 只触发一次事件处理函数\n\n\n\n&lt;template&gt;&lt;div&gt;    &lt;div @click=&quot;fatherFn&quot;&gt;        &lt;p @click.stop=&quot;oneFn&quot;&gt;.stop - 阻止事件冒泡&lt;/p&gt;        &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.stop&gt;去百度&lt;/a&gt;        &lt;p @click.once=&quot;twoFn&quot;&gt;点击观察事件处理函数执行几次&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            fatherFn()&#123;                console.log(&quot;fahter-触发click事件&quot;);            &#125;,            oneFn()&#123;                console.log(&quot;p标签点击了&quot;);            &#125;,            twoFn()&#123;                console.log(&quot;p标签被点击了&quot;);            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-on按键修饰符\n给键盘事件, 添加修饰符\n\n语法:\n\n@keyup.enter  -  监测回车按键\n@keyup.esc     -   监测返回按键\n更多修饰符\n\n&lt;template&gt;&lt;div&gt;    &lt;!-- 1. 绑定键盘按下事件.enter-回车 --&gt;    &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt;    &lt;!-- 2. .esc修饰符 - 取消键 --&gt;    &lt;hr&gt;    &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            enterFn()&#123;                console.log(&quot;用户按下的回车&quot;);            &#125;,            escFn()&#123;                console.log(&quot;用户按下esc键&quot;);            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-model\n把value属性和vue数据变量, 双向绑定到一起\n\n基础用法\n语法: v-model=”vue数据变量”\n双向数据绑定\n数据变化 -&gt; 视图自动同步\n视图变化 -&gt; 数据自动同步\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--         v-model 这个指令可以实现表单控件中数据与视图的双向绑定        1. 数据改变 =&gt; 视图自动同步        2. 视图改变 =&gt; 数据自动同步     --&gt;    &lt;!-- 1. input type=&#x27;test&#x27; 将 value 属性替换成 v-model --&gt;    &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;    &lt;!-- 2. 下拉选择框 select 将name属性替换成 v-model --&gt;    &lt;select v-model=&quot;city&quot;&gt;        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;    &lt;!-- 3. 单选框 将 name 属性替换成 v-model --&gt;    &lt;input type=&quot;radio&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt; 男    &lt;input type=&quot;radio&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt; 女    &lt;!-- 4. 复选框        将 name 属性替换成 v-model =&gt; v-model中绑定一个数组\t\t选中项就是数组中的每一个元素        将 name 属性替换成 v-model =&gt; v-model中绑定的是一个非数组\t\t当切换选择状态时会以布尔值的形式来做状态的切换    --&gt;    &lt;input type=&quot;checkbox&quot; value=&quot;唱&quot; v-model=&quot;hobby&quot;&gt; 唱    &lt;input type=&quot;checkbox&quot; value=&quot;跳&quot; v-model=&quot;hobby&quot;&gt; 跳    &lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; v-model=&quot;hobby&quot;&gt; rap    &lt;input type=&quot;checkbox&quot; value=&quot;唱&quot; v-model=&quot;hobby1&quot;&gt; 唱    &lt;input type=&quot;checkbox&quot; value=&quot;跳&quot; v-model=&quot;hobby2&quot;&gt; 跳    &lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; v-model=&quot;hobby3&quot;&gt; rap    &lt;!-- 5. 文本域  将双标签中的内容 替换为 标签内的 v-model指令 --&gt;    &lt;textarea v-model=&quot;textarea&quot;&gt;&lt;/textarea&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex05&#x27;,    data () &#123;        return &#123;            inputValue:&#x27;123&#x27;,            city:&#x27;&#x27;,            sex:&#x27;&#x27;,            hobby:[],            hobby1:&#x27;&#x27;,            hobby2:false,            hobby3:0,            textarea:&#x27;333&#x27;        &#125;    &#125;,&#125;&lt;/script&gt;\n\n原理：当一个Vue实现创建时，Vue会遍历data选项的属性，用Object.defineProperty将它们转化为getter/setter并且在内部追踪相关依赖，在属性被访问拒绝和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。\nv-model 的修饰符语法: v-model.修饰符=&quot;vue数据变量&quot;\n\n.number               以parseFloat转成数字类型（会自动清除非数字及以后部分）\n.trim （常用）  去除首尾空白字符\n.lazy                   在change时触发而非input时（一切可以触发change事件的情况，如失焦）\n\n&lt;template&gt;  &lt;div&gt;     &lt;span&gt;转化为数字&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.number=&quot;newNumber&quot;&gt;     &lt;hr&gt;     &lt;span&gt;取消前后空格&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.trim=&quot;newTrim&quot;&gt;     &lt;hr&gt;     &lt;span&gt;懒更新&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.lazy=&quot;newLazy&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex&#x27;,    data () &#123;        return &#123;            newNumber:&#x27;&#x27;,            newTrim:&#x27;&#x27;,            newLazy:&#x27;&#x27;        &#125;    &#125;&#125;&lt;/script&gt;\n\nv-text和v-html\n作用: 更新DOM对象的innerText/innerHTML\n注意： v-text或v-html会覆盖标签内的所有子元素\n\n语法:\n\nv-text=”vue数据变量”    \nv-html=”vue数据变量” \n\n&lt;template&gt;  &lt;div&gt;    &lt;!--       v-text =&gt; 代替了webapi中的 innerText      v-html =&gt; 代替了webapi中的 innerHTML      v-text 使用时不允许当前标签内有任何子元素      原因: 本来当前元素中的内容就会被v-text中的内容覆盖，\t      所以当前标签中的子元素显得毫无意义甚至影响页面的渲染效率    --&gt;    &lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt;    &lt;p v-html=&quot;text&quot;&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name:&#x27;DemoIndex07&#x27;,  data () &#123;    return &#123;      text:&#x27;&lt;span style=&quot;color: red;&quot;&gt;这是一个字符串&lt;/span&gt;&#x27;    &#125;  &#125;,&#125;&lt;/script&gt;\n\nv-show和v-if\nv-show控制标签的显示和隐藏，v-if控制标签在dom中是否存在\n\n\n语法:\nv-show=”vue变量”            \nv-if=”vue变量” \n\n\n原理\nv-show 用的display:none隐藏   (频繁切换使用)\nv-if  直接从DOM树上移除\n\n\n高级\nv-else使用\n\n\n使用场景及区别\nv-show 一般用于单个没有子元素或者子元素都是静态元素的标签\nv-if 常用于弹窗表单\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--     通过变量的boolean值隐式转化，来判断是true或者是false\t为true时显示，为false时隐藏    =&gt;     1. 变量是否必须是布尔值？\t   =&gt; 不必须是布尔值，只需要查看它的隐式转化结果       隐式转化为false的情况: 0 / &#x27;&#x27; / null / undefined / NaN     v-show=&quot;变量&quot;    原理: 给当前标签设置一个display: none; \t来进行隐藏操作，原来的这个标签元素还存在于dom数中    v-if=&quot;变量&quot;    原理: 直接将需要隐藏的元素从dom树中删除    还可以和 v-else-if 和 v-else进行连用，\t它的判断逻辑与 js中 if else 完全相同    当使用v-if/v-else-if/v-else 时\t他们之间必须是连续的兄弟标签    *** 选择v-show和v-if的直接条件: \t如果当前元素及内部子元素全是静态数据，那么使用v-show\t除此以外全用v-if    --&gt;    &lt;div v-show=&quot;flag&quot;&gt;v-show&lt;/div&gt;    &lt;div v-if=&quot;flag&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;div v-if=&quot;flag1 === 0&quot;&gt;显示为0&lt;/div&gt;    &lt;div v-else-if=&quot;flag1 === 1&quot;&gt;显示为1&lt;/div&gt;    &lt;div v-else&gt;显示为其他&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;DemoIndex08&quot;,  data() &#123;    return &#123;      flag: true,      msg: &quot;动态&quot;,      flag1: 0,    &#125;;  &#125;,&#125;;&lt;/script&gt;\n\nv-for循环\n渲染列表数据时，直接在标签结构中进行数组遍历\n循环时需要给v-for当前标签加上一个key属性，用来表现每个被循环出来的标签结构唯一且不同\n\n\n语法 （类比forEach）\n\nv-for=”(值, 索引) in 目标结构”\nv-for=”值 in 目标结构”\n\n\n目标结构:\n\n可以遍历数组 / 对象 / 数字 / 字符串 (可遍历结构)\n\n\n注意:\nv-for的临时变量名不能用到v-for范围外\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--         v-for 数据循环指令        语法:        与forEach的使用方式进行联合记忆\t\t它的每次循环得到的数据和索引的用法与forEach完全一样        1. v-for=&quot;(value, index) in 目标数据结构&quot;        2. v-for=&quot;value in 目标数据结构&quot;        在v-for循环体中\t\t必须为每一个循环标签加上一个key属性来表示当前标签的唯一性        forEach((value, index) =&gt; &#123;&#125;)        forEach(value =&gt; &#123;&#125;)    --&gt;    &lt;!-- 1. 循环简单数组 √ --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in arr&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 2. 循环复杂数组 =&gt; 数组对象 √ --&gt;    &lt;div&gt;        &lt;p v-for=&quot;value in arr2&quot; :key=&quot;value.id&quot;&gt;            &#123;&#123; value.name &#125;&#125; ----- &#123;&#123; value.age &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 3. 循环对象 =&gt; 循环的就是对象的属性名和属性值 √ --&gt;    &lt;!-- 参数1： 属性值    参数2： 属性名 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, key) in obj&quot; :key=&quot;key&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; key &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 4. 循环数字 --&gt;    &lt;!-- 参数1： 从1开始计数到最后的自然数  参数2： 下标索引从0开始计数 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in 10&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 5. 循环字符串 --&gt;    &lt;!-- 参数1： 字符串的每一个字符  参数2： 字符所在的下标索引，从0开始计数 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in &#x27;abcdefg&#x27;&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex10&#x27;,    data() &#123;        return &#123;            arr:[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;],            arr2:[                &#123; name:&#x27;cxk&#x27;, age:24, id:1&#125;,                &#123; name:&#x27;lbw&#x27;, age:30, id:2&#125;            ],            obj:&#123;                name:&#x27;cxk&#x27;,                age:111,                sex:&#x27;不详&#x27;            &#125;,            arr3:[1, 2, 3, 4, 5, 6]        &#125;    &#125;,&#125;;&lt;/script&gt;\n\n注意：  避免v-for和v-if同时使用\n​        当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度\n解决方法：在v-for前对数组进行筛选\n&lt;!--     v-for 会比 v-if 有更高的优先级，那么数据渲染出来以后才会进行v-if判断，一增一删毫无意义，所以不希望在同一个标签中使用v-if    解决方案： 直接把v-if中的逻辑判断放到filter的函数执行体中即可--&gt;&lt;p v-for=&quot;(value, index) in arr3.filter(value =&gt; value &gt;= 3)&quot; :key=&quot;index&quot;&gt;    &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;&lt;/p&gt;\n\nv-for更新监测\n原因: 当v-for遍历的目标结构改变, Vue触发v-for的更新\n\n&lt;div&gt;  &lt;div v-for=&quot;(value, index) in arr1&quot; :key=&quot;index&quot;&gt;    &#123;&#123; value &#125;&#125;  &lt;/div&gt;  &lt;hr /&gt;  &lt;!-- 数组的翻转 --&gt;  &lt;button @click=&quot;reverseBtn&quot;&gt;点击翻转数组&lt;/button&gt;  &lt;!-- 截取数组的前3个 --&gt;  &lt;button @click=&quot;sliceBtn&quot;&gt;点击截取数组&lt;/button&gt;  &lt;!-- 将第一个元素改成1000 --&gt;  &lt;button @click=&quot;changeFirstBtn&quot;&gt;点击修改第一个元素&lt;/button&gt;&lt;/div&gt;\n\nexport default &#123;  name: &quot;DemoIndex01&quot;,  data() &#123;    return &#123;      arr1: [5, 3, 2, 1, 9],    &#125;;  &#125;,  methods: &#123;    // 翻转数组的方法    reverseBtn() &#123;      this.arr1.reverse();    &#125;,    // 截取数组的前三位    sliceBtn() &#123;      // 发现使用slice进行数组截取，页面上不会发生变化      // 其原因是slice不会改变原数组，所以需要重新赋值      // this.arr1 = this.arr1.slice(0, 3)      // 标准修改方法 ↓      this.arr1.splice(3, 2);    &#125;,    // 修改第一个元素    changeFirstBtn() &#123;      // 这种直接通过索引改变数组某个元素的方式不是标准修改形式      // 通过length进行数组元素的增加和删除的方式也不是标准修改形式      this.arr1[0] = 1000;      // 发现通过索引到的方式无法让页面监听到数组元素的改变      // 通过 vue 提供的内置方法来强制刷新 =&gt; this.$set      // this.$set(更新的目标结构, 更新的位置, 更新的数据)      // 如果某个修改数据的方法需要用到this.$set才可以实现数据监听时，      // 那么这个方法一定不是一个标准化的规范修改过程，一定有与之替换的标准化解决方案，      // 所以去用标准方案吧      this.$set(this.arr1, 0, 1000);      // splice 是修改数组中某个元素的标准化解决方案      // this.arr1.splice(0, 1, 1000)    &#125;,  &#125;,&#125;;\n\n\n数组变更方法, 就会导致v-for更新, 页面更新\n\n数组非变更方法, 返回新数组, 就不会导致v-for更新, 可采用覆盖数组或this.$set()\n\n\nv-for 立即更新\nv-for 的默认行为会尝试原地修改元素而不是移动它们。\n简单来说就是不删除原来的dom元素，而是尽量去修改各循环元素内部的值\n\n\n&lt;div&gt;    &lt;ul&gt;        &lt;li v-for=&quot;(val, ind) in arr&quot; :key=&quot;ind&quot;&gt;            &#123;&#123; val &#125;&#125;        &lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;btn&quot;&gt;下标1位置插入新来的&lt;/button&gt;&lt;/div&gt;\n\nexport default &#123;    data()&#123;        return &#123;            arr: [&#x27;老大&#x27;, &quot;老二&quot;, &#x27;老三&#x27;]        &#125;    &#125;,    methods: &#123;        btn()&#123;            // 索引为1的位置插入一个元素            this.arr.splice(1, 0, &#x27;新来的&#x27;)        &#125;    &#125;&#125;\n\nVue 过滤器filter定义使用\n目的: 转换格式, 过滤器就是一个函数, 传入值返回处理后的值\n简单理解就是在数据渲染到页面之前的过程中，进行一次包装处理\n\n注意：过滤器只能用在, 插值表达式和v-bind表达式\nVue中的过滤器场景：\n\n字母转大写, 输入”hello”, 输出”HELLO”\n字符串翻转, “输入hello, world”, 输出”dlrow ,olleh”\n\n语法: \n\nVue.filter(“过滤器名”, (值) =&gt; {return “返回处理后的值”})\nfilters: {过滤器名字: (值) =&gt; {return “返回处理后的值”}\n\n注意：一定要有返回值\n例子:\n\n全局定义字母都大写的过滤器\n局部定义字符串翻转的过滤器\n\n&lt;div&gt;    &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;!-- 2. 过滤器使用    语法: &#123;&#123; 值 | 过滤器名字 &#125;&#125;    --&gt;    &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; msg | toUp &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      msg: &#x27;Hello, Vue&#x27;    &#125;  &#125;,  // 方式2: 局部 - 过滤器  // 只能在当前vue文件内使用  /*     语法:      filters: &#123;       过滤器名字 (val) &#123;         return 处理后的值       &#125;     &#125;  */  filters: &#123;    toUp (val) &#123;      return val.toUpperCase()    &#125;  &#125;&#125;\n\nmain.js\n// 过滤器接参数Vue.filter(&quot;reverse&quot;, (val, s) =&gt; &#123;    return val.split(&quot;&quot;).reverse().join(s || &#x27;&#x27;)&#125;)\n\n传参和多过滤器\n可同时使用多个过滤器, 或者给过滤器传参\n从左往右依次过滤\n\n语法:\n\n过滤器传参:   vue变量 | 过滤器(实参) \n多个过滤器:   vue变量 | 过滤器1 | 过滤器2\n\n&lt;div&gt;    &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;!-- 1.      给过滤器传值      语法: vue变量 | 过滤器名(值)     --&gt;    &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse(&#x27;|&#x27;) &#125;&#125;&lt;/p&gt;    &lt;!-- 2.      多个过滤利使用      语法: vue变量 | 过滤器1 | 过滤器2     --&gt;    &lt;p&gt;&#123;&#123; msg | toUp | reverse(&#x27;|&#x27;) &#125;&#125;&lt;/p&gt;  &lt;/div&gt;\n\nVue 计算属性computed\n场景： 页面上某一个变量是有其他两个或多个变量通过一定逻辑后运算得到的时候，可以用到计算属性进行简化\n\n基础语法语法:\ncomputed: &#123;    &quot;计算属性名&quot; () &#123;        return &quot;值&quot;    &#125;&#125;\n\n需求：求2个数的和显示到页面上\n&lt;div&gt;    &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      a: 10,      b: 20    &#125;  &#125;,  // 计算属性:  // 场景: 一个变量的值, 需要用另外变量计算而得来  /*    语法:    computed: &#123;      计算属性名 () &#123;        return 值      &#125;    &#125;  */ // 注意: 计算属性和data属性都是变量-不能重名 // 注意2: 函数内变量变化, 会自动重新计算结果返回  computed: &#123;    num()&#123;      return this.a + this.b    &#125;  &#125;&#125;\n\n总结：\n\n使用场景： 当变量的值, 需要通过别人计算而得来\n特点：函数内使用的变量改变, 重新计算结果返回\n注意事项：计算属性名和data里名字不能重复\n\ncomputed缓存\n目标: 计算属性是基于它们的依赖项的值结果进行缓存的，只要依赖的变量不变, 都直接从缓存取结果\n以上也是计算属性和方法的区别\n\n场景： 通过函数与计算属性做对比\n&lt;div&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\n\n\nexport default &#123;  data()&#123;    return &#123;      msg: &quot;Hello, Vue&quot;    &#125;  &#125;,  // 计算属性优势:  // 带缓存  // 计算属性对应函数执行后, 会把return值缓存起来  // 依赖项不变, 多次调用都是从缓存取值  // 依赖项值-变化, 函数会&quot;自动&quot;重新执行-并缓存新的值  computed: &#123;    reverseMessage()&#123;      console.log(&quot;计算属性执行了&quot;);      return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;)    &#125;  &#125;,  methods: &#123;    getMessage()&#123;      console.log(&quot;函数执行了&quot;);      return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;)    &#125;  &#125;&#125;\n\n小结：\n\n计算属性优势：\n带缓存 \n依赖项不变, 直接从缓存取\n依赖项改变, 函数自动执行并重新缓存\n\n\n 因为要消耗内存，所以也是计算属性的缺点\n\ncomputed的完整写法\n计算属性也是变量, 如果想要直接赋值, 需要使用完整写法\n场景： 当计算属性变量作为表单的值时\n注意事项：在实际开发过程中，几乎(99.9%)使用完整写法的计算属性，只有用在全选反选上\n\n语法：\ncomputed: &#123;    &quot;属性名&quot;: &#123;        set(值)&#123;                    &#125;,        get() &#123;            return &quot;值&quot;        &#125;    &#125;&#125;\n\n需求：让计算属性给v-model使用\n&lt;div&gt;    &lt;span&gt;姓名:&lt;/span&gt;    &lt;input type=&quot;text&quot; v-model=&quot;full&quot;&gt;&lt;/div&gt;\n\ncomputed: &#123;    data () &#123;        return &#123;            num1: 10,            num2: 20，            num3: 0        &#125;    &#125;,    full: &#123;        // 给full赋值触发set方法        set(val)&#123;            this.num3 = val        &#125;,        // 使用full的值触发get方法        get()&#123;            return this.num1 + this.num2        &#125;    &#125;&#125;\n\n小结：\n\n当需要给计算属性赋值时，会用到计算属性，但这种情况非常少。\nset函数和get函数的执行时机\nset接收要赋予的值\nget里要返回给这个计算属性具体值\n\n\n\nVue 侦听器watch\n可以侦听data/computed属性值改变\n\n​        一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。\n基本语法语法：\nwatch: &#123;    &quot;被侦听的属性名&quot; (newVal, oldVal)&#123;            &#125;&#125;\n\n例子：\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;obj.name&quot;&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      name: &quot;&quot;,      obj: &#123;        name: &#x27;&#x27;      &#125;    &#125;  &#125;,  // 目标: 侦听到name值的改变  /*  语法:    watch: &#123;      变量名 (newVal, oldVal)&#123;        // 变量名对应值改变这里自动触发      &#125;    &#125;  */  watch: &#123;    // newVal: 当前最新值    // oldVal: 上一刻值    name(newVal, oldVal)&#123;      console.log(newVal, oldVal);    &#125;,    // 监听引用类型    obj(newVal, oldVal) &#123;      console.log(newVal, oldVal)    &#125;  &#125;&#125;\n\n发现，引用类型的对象无法监听到，该怎么办?\n深度侦听和立即执行\n侦听引用数据类型, 或者立即执行侦听函数\n\n语法：\nwatch: &#123;    &quot;要侦听的属性名&quot;: &#123;        immediate: true, // 立即执行        deep: true, // 深度侦听复杂类型内变化        handler (newVal, oldVal) &#123;                    &#125;    &#125;&#125;\n\n例子：\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;user.age&quot;&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      user: &#123;        name: &quot;&quot;,        age: 0      &#125;    &#125;  &#125;,  // 目标: 侦听对象  /*  语法:    watch: &#123;      变量名 (newVal, oldVal)&#123;        // 变量名对应值改变这里自动触发      &#125;,      变量名: &#123;        handler(newVal, oldVal)&#123;        &#125;,        deep: true, // 深度侦听(对象里面层的值改变)        immediate: true // 立即侦听(网页打开handler执行一次)      &#125;    &#125;  */  watch: &#123;    user: &#123;      handler(newVal, oldVal)&#123;        // user里的对象        console.log(newVal, oldVal);      &#125;,      deep: true,      immediate: true    &#125;  &#125;&#125;\n\n\n总结: immediate立即侦听, deep深度侦听, handler固定方法触发\n\n补充： 另一种监听对象特定属性的方式​        通过设置key为对象属性的索引，value为监听回调方法的形式\nwatch: &#123;   &#x27;user.name&#x27;: (newVal, oldVal) =&gt; &#123;     console.log(newVal, oldVal)   &#125; &#125;\n\n"}]