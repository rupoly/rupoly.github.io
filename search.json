[{"title":"Vue笔记","url":"/2022/11/22/Vue%E7%AC%94%E8%AE%B0/","content":"接近Vue入口文件的特点​    要想要某个页面或文件在项目中生效，一定会直接或间接的与入口文件产生联系\n\n引入vue依赖 =&gt; 如果引入的是第三方依赖，那么路径不必写成相对或绝对路径import Vue from &#x27;vue&#x27;\n引入根组件import App from &#x27;./APP.vue&#x27;\n\nvue项目的一个控制台打印提示，默认关闭Vue.config.productionTip = false\n\n\n实例化vue对象，并且挂载到唯一html页面上new Vue(&#123;  render: h =&gt; h(App), // 渲染函数，告诉vue要渲染的组件&#125;).$mount(&#x27;#app&#x27;) // 确定vue实例挂载的盒子\n\n\n自定义vue中开发服务器配置及关闭eslint检查自定义服务器配置在vue.config.js文件中，moudule.exports添加devServer:&#123;  // 自定义开发服务器配置    prot: 3000 // 自定义端口号&#125;\n全局关闭eslint检查lintOnSave:false // \n局部关闭eslint检查​    直接添加//注释即可\n// 只能忽略下一行代码的eslint检测：// eslint-disable-next-linelet a = 10// 只能忽略当前行代码的eslint检测：let b = 20// eslint-disable-line// 忽略后续代码的eslint检测：/* eslint-disable *//* eslint-disable */let c = 30 let d = 40let e = 50// 开启后续代码的eslint检测：/* eslint-enable *//* eslint-enable */let f = 60\n\n\n关于.vue文件中的三个标签\n\ntemplate标签标签模板 =&gt; 对应记忆对照html文件中的&lt;html&gt;标签结构vue模板标签中，只能有一个根标签!\nscript标签// js相关的代码// 在js中 有一个 export default &#123;&#125; 结构， 在这个结构中需要遵循vue的代码规则\nstyle标签/* 当前组件样式表 - 期望每个组件中的style 标签只能影响当前组件中的标签内容 *//* 只需要在style 标签中添加一个属性 - scoped 就可以让样式只作用于当前组件的标签 *//* 原理: scoped 属性，会为每一个样式表自动添加当前组件中所被设置的自定义属性（data-v-hash随机数），形参一个复合选择器，而能够被选中的标签均存在于当前组件中，所以可以被区分开 *//* 规律/要求: 只要组件需要设置style样式，就在style标签中添加 scoped 属性 */\n\nMVVM模型的理解​    设计模式: 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。\n\nMVVM，一种软件架构模式，决定了写代码的思想和层次\nM：   model数据模型          (data里定义)    \nV：    view视图                   （html页面）\nVM： ViewModel视图模型  (vue.js源码)\n\n\n\n\nMVVM通过数据双向绑定让数据自动地双向同步  不再需要操作DOM\nV（修改视图） -&gt; M（数据自动同步）\nM（修改数据） -&gt; V（视图自动同步）\n\n\n\n\n总结：\n​        vue使用的mvvm设计模式。MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。\n在MVVM模型之前使用的MVC模型：\n\n​        MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。\n原生的HTML + JS就是使用的这个模型\n\n将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。\n\n\n\n\n\n\n关于Vue中的属性V-bind动态属性详解语法： v-bind:属性名=”vue中定义的变量/表达式”\n简化的语法： 将v-bind:属性名 转化为 =&gt; :属性名\n&lt;a v-bind:href=&quot;baiduUrl&quot;&gt;&#123;&#123; url &#125;&#125;&lt;/a&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            baiduUrl:&#x27;http://www.baidu.com&#x27;,            url:&#x27;www.baidu.com&#x27;,        &#125;    &#125;&#125;\n\n注意点：\n关于v-bind动态属性作用于图片时尤其需要注意：v-bind 会直接把资源路径认定为字符串\n解决方式：直接在v-bind动态属性后面传递实际的资源\n方法1：通过import引入资源文件，在data中进行定义，最后在动态属性中使用\n&lt;img v-bind:src=&quot;img1&quot; alt=&quot;&quot;&gt;\n\n// 引入importimport img from &#x27;../assets/logo.png&#x27;export default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 在data中设置路径，引入            img1:img,        &#125;    &#125;&#125;\n\n方法2：通过require 引入资源文件，直接在动态属性中使用\n&lt;img v-bind:src=&quot;img2&quot; alt=&quot;&quot;&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 通过require 引入资源文件，直接在动态属性中使用            img2:require(&#x27;../assets/logo.png&#x27;)        &#125;    &#125;&#125;\n\n开发中一般会使用方法2，优势： require引入资源的方式是按需的，这样一来，页面初始更新效率会更高\n"}]