[{"title":"Vue笔记","url":"/2022/11/22/Vue%E7%AC%94%E8%AE%B0/","content":"接近Vue入口文件的特点​    要想要某个页面或文件在项目中生效，一定会直接或间接的与入口文件产生联系\n\n引入vue依赖 =&gt; 如果引入的是第三方依赖，那么路径不必写成相对或绝对路径import Vue from &#x27;vue&#x27;\n引入根组件import App from &#x27;./APP.vue&#x27;\n\nvue项目的一个控制台打印提示，默认关闭Vue.config.productionTip = false\n\n\n实例化vue对象，并且挂载到唯一html页面上new Vue(&#123;  render: h =&gt; h(App), // 渲染函数，告诉vue要渲染的组件&#125;).$mount(&#x27;#app&#x27;) // 确定vue实例挂载的盒子\n\n\n自定义vue中开发服务器配置及关闭eslint检查自定义服务器配置在vue.config.js文件中，moudule.exports添加devServer:&#123;  // 自定义开发服务器配置    prot: 3000 // 自定义端口号&#125;\n全局关闭eslint检查lintOnSave:false // \n局部关闭eslint检查​    直接添加//注释即可\n// 只能忽略下一行代码的eslint检测：// eslint-disable-next-linelet a = 10// 只能忽略当前行代码的eslint检测：let b = 20// eslint-disable-line// 忽略后续代码的eslint检测：/* eslint-disable *//* eslint-disable */let c = 30 let d = 40let e = 50// 开启后续代码的eslint检测：/* eslint-enable *//* eslint-enable */let f = 60\n\n关于.vue文件中的三个标签\ntemplate标签标签模板 =&gt; 对应记忆对照html文件中的&lt;html&gt;标签结构vue模板标签中，只能有一个根标签!\nscript标签// js相关的代码// 在js中 有一个 export default &#123;&#125; 结构， 在这个结构中需要遵循vue的代码规则\nstyle标签/* 当前组件样式表 - 期望每个组件中的style 标签只能影响当前组件中的标签内容 *//* 只需要在style 标签中添加一个属性 - scoped 就可以让样式只作用于当前组件的标签 *//* 原理: scoped 属性，会为每一个样式表自动添加当前组件中所被设置的自定义属性（data-v-hash随机数），形成一个复合选择器，而能够被选中的标签均存在于当前组件中，所以可以被区分开 *//* 规律/要求: 只要组件需要设置style样式，就在style标签中添加 scoped 属性 */\n\nMVVM模型的理解​    设计模式: 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。\n\nMVVM，一种软件架构模式，决定了写代码的思想和层次\nM：   model数据模型          (data里定义)    \nV：    view视图                   （html页面）\nVM： ViewModel视图模型  (vue.js源码)\n\n\n\n\nMVVM通过数据双向绑定让数据自动地双向同步  不再需要操作DOM\nV（修改视图） -&gt; M（数据自动同步）\nM（修改数据） -&gt; V（视图自动同步）\n\n\n\n\n总结：\n​        vue使用的mvvm设计模式。MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。\n在MVVM模型之前使用的MVC模型：\n\n​        MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。\n原生的HTML + JS就是使用的这个模型\n\n将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。\n\n\n\n\n\n\n关于Vue中的属性v-bind动态属性详解语法： v-bind:属性名=”vue中定义的变量/表达式”\n简化的语法： 将v-bind:属性名 转化为 =&gt; :属性名\n&lt;a v-bind:href=&quot;baiduUrl&quot;&gt;&#123;&#123; url &#125;&#125;&lt;/a&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            baiduUrl:&#x27;http://www.baidu.com&#x27;,            url:&#x27;www.baidu.com&#x27;,        &#125;    &#125;&#125;\n\n注意点：\n关于v-bind动态属性作用于图片时尤其需要注意：v-bind 会直接把资源路径认定为字符串\n解决方式：直接在v-bind动态属性后面传递实际的资源\n方法1：通过import引入资源文件，在data中进行定义，最后在动态属性中使用\n&lt;img v-bind:src=&quot;img1&quot; alt=&quot;&quot;&gt;\n\n// 引入importimport img from &#x27;../assets/logo.png&#x27;export default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 在data中设置路径，引入            img1:img,        &#125;    &#125;&#125;\n\n方法2：通过require 引入资源文件，直接在动态属性中使用\n&lt;img v-bind:src=&quot;img2&quot; alt=&quot;&quot;&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 通过require 引入资源文件，直接在动态属性中使用            img2:require(&#x27;../assets/logo.png&#x27;)        &#125;    &#125;&#125;\n\n开发中一般会使用方法2，优势： require引入资源的方式是按需的，这样一来，页面初始更新效率会更高\nv-on事件绑定语法：\nv-on:事件名=&quot;简单的函数执行体&quot; =&gt; 只有一行代码v-on:事件名=&quot;methods中定义的方法&quot;v-on:事件名=&quot;methods中定义的方法(实际参数)&quot;简写: v-on: =&gt; @     @事件名=&quot;methods中定义的方法&quot;\n\n使用：\n&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count++&quot;&gt;点我加1&lt;/button&gt;&lt;button v-on:click=&quot;addCount2&quot;&gt;点我加2并打印&lt;/button&gt;&lt;button @click=&quot;addCountN(7)&quot;&gt;点我加7&lt;/button&gt;\n\nexport default &#123;  name: &quot;DemoIndex03&quot;,  data() &#123;    return &#123;      count: 0,    &#125;;  &#125;,  // vue组件的方法定义在methods对象中  methods: &#123;    // 点击加2并打印    addCount2() &#123;      this.count += 2;      console.log(this.count);    &#125;,    // 点击加按钮传递过来的数字    addCountN(num) &#123;      this.count += num;    &#125;,  &#125;,&#125;;\n\nv-on获取事件对象\nvue事件处理函数中, 拿到事件对象\n\n语法:\n\n无传参, 通过形参直接接收\n传参, 通过$event指代事件对象传给事件处理函数\n\n&lt;template&gt;&lt;div&gt;    &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;hr /&gt;    &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/a&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            // 1. 事件触发, 无传值, 可以直接获取事件对象是            one(e)&#123;                console.log(e)                e.preventDefault()            &#125;,            // 2. 事件触发, 传值, 需要手动传入$event            two(num, e)&#123;                console.log(e)                e.preventDefault()            &#125;        &#125;    &#125;;&lt;/script&gt;\n\n如何不用e这个事件对象而阻止默认行为呢？↓  事件修饰符\nv-on修饰符语法:\n\n@事件名.修饰符=”methods里函数”\n.stop - 阻止事件冒泡\n.prevent - 阻止默认行为\n.once - 程序运行期间, 只触发一次事件处理函数\n\n\n\n&lt;template&gt;&lt;div&gt;    &lt;div @click=&quot;fatherFn&quot;&gt;        &lt;p @click.stop=&quot;oneFn&quot;&gt;.stop - 阻止事件冒泡&lt;/p&gt;        &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.stop&gt;去百度&lt;/a&gt;        &lt;p @click.once=&quot;twoFn&quot;&gt;点击观察事件处理函数执行几次&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            fatherFn()&#123;                console.log(&quot;fahter-触发click事件&quot;);            &#125;,            oneFn()&#123;                console.log(&quot;p标签点击了&quot;);            &#125;,            twoFn()&#123;                console.log(&quot;p标签被点击了&quot;);            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-on按键修饰符\n给键盘事件, 添加修饰符\n\n语法:\n\n@keyup.enter  -  监测回车按键\n@keyup.esc     -   监测返回按键\n更多修饰符\n\n&lt;template&gt;&lt;div&gt;    &lt;!-- 1. 绑定键盘按下事件.enter-回车 --&gt;    &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt;    &lt;!-- 2. .esc修饰符 - 取消键 --&gt;    &lt;hr&gt;    &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            enterFn()&#123;                console.log(&quot;用户按下的回车&quot;);            &#125;,            escFn()&#123;                console.log(&quot;用户按下esc键&quot;);            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-model\n把value属性和vue数据变量, 双向绑定到一起\n\n基础用法\n语法: v-model=”vue数据变量”\n双向数据绑定\n数据变化 -&gt; 视图自动同步\n视图变化 -&gt; 数据自动同步\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--         v-model 这个指令可以实现表单控件中数据与视图的双向绑定        1. 数据改变 =&gt; 视图自动同步        2. 视图改变 =&gt; 数据自动同步     --&gt;    &lt;!-- 1. input type=&#x27;test&#x27; 将 value 属性替换成 v-model --&gt;    &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;    &lt;!-- 2. 下拉选择框 select 将name属性替换成 v-model --&gt;    &lt;select v-model=&quot;city&quot;&gt;        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;    &lt;!-- 3. 单选框 将 name 属性替换成 v-model --&gt;    &lt;input type=&quot;radio&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt; 男    &lt;input type=&quot;radio&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt; 女    &lt;!-- 4. 复选框        将 name 属性替换成 v-model =&gt; v-model中绑定一个数组\t\t选中项就是数组中的每一个元素        将 name 属性替换成 v-model =&gt; v-model中绑定的是一个非数组\t\t当切换选择状态时会以布尔值的形式来做状态的切换    --&gt;    &lt;input type=&quot;checkbox&quot; value=&quot;唱&quot; v-model=&quot;hobby&quot;&gt; 唱    &lt;input type=&quot;checkbox&quot; value=&quot;跳&quot; v-model=&quot;hobby&quot;&gt; 跳    &lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; v-model=&quot;hobby&quot;&gt; rap    &lt;input type=&quot;checkbox&quot; value=&quot;唱&quot; v-model=&quot;hobby1&quot;&gt; 唱    &lt;input type=&quot;checkbox&quot; value=&quot;跳&quot; v-model=&quot;hobby2&quot;&gt; 跳    &lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; v-model=&quot;hobby3&quot;&gt; rap    &lt;!-- 5. 文本域  将双标签中的内容 替换为 标签内的 v-model指令 --&gt;    &lt;textarea v-model=&quot;textarea&quot;&gt;&lt;/textarea&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex05&#x27;,    data () &#123;        return &#123;            inputValue:&#x27;123&#x27;,            city:&#x27;&#x27;,            sex:&#x27;&#x27;,            hobby:[],            hobby1:&#x27;&#x27;,            hobby2:false,            hobby3:0,            textarea:&#x27;333&#x27;        &#125;    &#125;,&#125;&lt;/script&gt;\n\n原理：当一个Vue实现创建时，Vue会遍历data选项的属性，用Object.defineProperty将它们转化为getter/setter并且在内部追踪相关依赖，在属性被访问拒绝和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。\nv-model 的修饰符语法: v-model.修饰符=&quot;vue数据变量&quot;\n\n.number               以parseFloat转成数字类型（会自动清除非数字及以后部分）\n.trim （常用）  去除首尾空白字符\n.lazy                   在change时触发而非input时（一切可以触发change事件的情况，如失焦）\n\n&lt;template&gt;  &lt;div&gt;     &lt;span&gt;转化为数字&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.number=&quot;newNumber&quot;&gt;     &lt;hr&gt;     &lt;span&gt;取消前后空格&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.trim=&quot;newTrim&quot;&gt;     &lt;hr&gt;     &lt;span&gt;懒更新&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.lazy=&quot;newLazy&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex&#x27;,    data () &#123;        return &#123;            newNumber:&#x27;&#x27;,            newTrim:&#x27;&#x27;,            newLazy:&#x27;&#x27;        &#125;    &#125;&#125;&lt;/script&gt;\n\nv-text和v-html\n作用: 更新DOM对象的innerText/innerHTML\n注意： v-text或v-html会覆盖标签内的所有子元素\n\n语法:\n\nv-text=”vue数据变量”    \nv-html=”vue数据变量” \n\n&lt;template&gt;  &lt;div&gt;    &lt;!--       v-text =&gt; 代替了webapi中的 innerText      v-html =&gt; 代替了webapi中的 innerHTML      v-text 使用时不允许当前标签内有任何子元素      原因: 本来当前元素中的内容就会被v-text中的内容覆盖，\t      所以当前标签中的子元素显得毫无意义甚至影响页面的渲染效率    --&gt;    &lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt;    &lt;p v-html=&quot;text&quot;&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name:&#x27;DemoIndex07&#x27;,  data () &#123;    return &#123;      text:&#x27;&lt;span style=&quot;color: red;&quot;&gt;这是一个字符串&lt;/span&gt;&#x27;    &#125;  &#125;,&#125;&lt;/script&gt;\n\nv-show和v-if\nv-show控制标签的显示和隐藏，v-if控制标签在dom中是否存在\n\n\n语法:\nv-show=”vue变量”            \nv-if=”vue变量” \n\n\n原理\nv-show 用的display:none隐藏   (频繁切换使用)\nv-if  直接从DOM树上移除\n\n\n高级\nv-else使用\n\n\n使用场景及区别\nv-show 一般用于单个没有子元素或者子元素都是静态元素的标签\nv-if 常用于弹窗表单\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--     通过变量的boolean值隐式转化，来判断是true或者是false\t为true时显示，为false时隐藏    =&gt;     1. 变量是否必须是布尔值？\t   =&gt; 不必须是布尔值，只需要查看它的隐式转化结果       隐式转化为false的情况: 0 / &#x27;&#x27; / null / undefined / NaN     v-show=&quot;变量&quot;    原理: 给当前标签设置一个display: none; \t来进行隐藏操作，原来的这个标签元素还存在于dom数中    v-if=&quot;变量&quot;    原理: 直接将需要隐藏的元素从dom树中删除    还可以和 v-else-if 和 v-else进行连用，\t它的判断逻辑与 js中 if else 完全相同    当使用v-if/v-else-if/v-else 时\t他们之间必须是连续的兄弟标签    *** 选择v-show和v-if的直接条件: \t如果当前元素及内部子元素全是静态数据，那么使用v-show\t除此以外全用v-if    --&gt;    &lt;div v-show=&quot;flag&quot;&gt;v-show&lt;/div&gt;    &lt;div v-if=&quot;flag&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;div v-if=&quot;flag1 === 0&quot;&gt;显示为0&lt;/div&gt;    &lt;div v-else-if=&quot;flag1 === 1&quot;&gt;显示为1&lt;/div&gt;    &lt;div v-else&gt;显示为其他&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;DemoIndex08&quot;,  data() &#123;    return &#123;      flag: true,      msg: &quot;动态&quot;,      flag1: 0,    &#125;;  &#125;,&#125;;&lt;/script&gt;\n\nv-for循环\n渲染列表数据时，直接在标签结构中进行数组遍历\n循环时需要给v-for当前标签加上一个key属性，用来表现每个被循环出来的标签结构唯一且不同\n\n\n语法 （类比forEach）\n\nv-for=”(值, 索引) in 目标结构”\nv-for=”值 in 目标结构”\n\n\n目标结构:\n\n可以遍历数组 / 对象 / 数字 / 字符串 (可遍历结构)\n\n\n注意:\nv-for的临时变量名不能用到v-for范围外\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--         v-for 数据循环指令        语法:        与forEach的使用方式进行联合记忆\t\t它的每次循环得到的数据和索引的用法与forEach完全一样        1. v-for=&quot;(value, index) in 目标数据结构&quot;        2. v-for=&quot;value in 目标数据结构&quot;        在v-for循环体中\t\t必须为每一个循环标签加上一个key属性来表示当前标签的唯一性        forEach((value, index) =&gt; &#123;&#125;)        forEach(value =&gt; &#123;&#125;)    --&gt;    &lt;!-- 1. 循环简单数组 √ --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in arr&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 2. 循环复杂数组 =&gt; 数组对象 √ --&gt;    &lt;div&gt;        &lt;p v-for=&quot;value in arr2&quot; :key=&quot;value.id&quot;&gt;            &#123;&#123; value.name &#125;&#125; ----- &#123;&#123; value.age &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 3. 循环对象 =&gt; 循环的就是对象的属性名和属性值 √ --&gt;    &lt;!-- 参数1： 属性值    参数2： 属性名 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, key) in obj&quot; :key=&quot;key&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; key &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 4. 循环数字 --&gt;    &lt;!-- 参数1： 从1开始计数到最后的自然数  参数2： 下标索引从0开始计数 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in 10&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 5. 循环字符串 --&gt;    &lt;!-- 参数1： 字符串的每一个字符  参数2： 字符所在的下标索引，从0开始计数 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in &#x27;abcdefg&#x27;&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex10&#x27;,    data() &#123;        return &#123;            arr:[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;],            arr2:[                &#123; name:&#x27;cxk&#x27;, age:24, id:1&#125;,                &#123; name:&#x27;lbw&#x27;, age:30, id:2&#125;            ],            obj:&#123;                name:&#x27;cxk&#x27;,                age:111,                sex:&#x27;不详&#x27;            &#125;,            arr3:[1, 2, 3, 4, 5, 6]        &#125;    &#125;,&#125;;&lt;/script&gt;\n\n注意：  避免v-for和v-if同时使用\n​        当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度\n解决方法：在v-for前对数组进行筛选\n&lt;!--     v-for 会比 v-if 有更高的优先级，那么数据渲染出来以后才会进行v-if判断，一增一删毫无意义，所以不希望在同一个标签中使用v-if    解决方案： 直接把v-if中的逻辑判断放到filter的函数执行体中即可--&gt;&lt;p v-for=&quot;(value, index) in arr3.filter(value =&gt; value &gt;= 3)&quot; :key=&quot;index&quot;&gt;    &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;&lt;/p&gt;\n\nv-for更新监测\n原因: 当v-for遍历的目标结构改变, Vue触发v-for的更新\n\n&lt;div&gt;  &lt;div v-for=&quot;(value, index) in arr1&quot; :key=&quot;index&quot;&gt;    &#123;&#123; value &#125;&#125;  &lt;/div&gt;  &lt;hr /&gt;  &lt;!-- 数组的翻转 --&gt;  &lt;button @click=&quot;reverseBtn&quot;&gt;点击翻转数组&lt;/button&gt;  &lt;!-- 截取数组的前3个 --&gt;  &lt;button @click=&quot;sliceBtn&quot;&gt;点击截取数组&lt;/button&gt;  &lt;!-- 将第一个元素改成1000 --&gt;  &lt;button @click=&quot;changeFirstBtn&quot;&gt;点击修改第一个元素&lt;/button&gt;&lt;/div&gt;\n\nexport default &#123;  name: &quot;DemoIndex01&quot;,  data() &#123;    return &#123;      arr1: [5, 3, 2, 1, 9],    &#125;;  &#125;,  methods: &#123;    // 翻转数组的方法    reverseBtn() &#123;      this.arr1.reverse();    &#125;,    // 截取数组的前三位    sliceBtn() &#123;      // 发现使用slice进行数组截取，页面上不会发生变化      // 其原因是slice不会改变原数组，所以需要重新赋值      // this.arr1 = this.arr1.slice(0, 3)      // 标准修改方法 ↓      this.arr1.splice(3, 2);    &#125;,    // 修改第一个元素    changeFirstBtn() &#123;      // 这种直接通过索引改变数组某个元素的方式不是标准修改形式      // 通过length进行数组元素的增加和删除的方式也不是标准修改形式      this.arr1[0] = 1000;      // 发现通过索引到的方式无法让页面监听到数组元素的改变      // 通过 vue 提供的内置方法来强制刷新 =&gt; this.$set      // this.$set(更新的目标结构, 更新的位置, 更新的数据)      // 如果某个修改数据的方法需要用到this.$set才可以实现数据监听时，      // 那么这个方法一定不是一个标准化的规范修改过程，一定有与之替换的标准化解决方案，      // 所以去用标准方案吧      this.$set(this.arr1, 0, 1000);      // splice 是修改数组中某个元素的标准化解决方案      // this.arr1.splice(0, 1, 1000)    &#125;,  &#125;,&#125;;\n\n\n数组变更方法, 就会导致v-for更新, 页面更新\n\n数组非变更方法, 返回新数组, 就不会导致v-for更新, 可采用覆盖数组或this.$set()\n\n\nv-for 立即更新\nv-for 的默认行为会尝试原地修改元素而不是移动它们。\n简单来说就是不删除原来的dom元素，而是尽量去修改各循环元素内部的值\n\n\n&lt;div&gt;    &lt;ul&gt;        &lt;li v-for=&quot;(val, ind) in arr&quot; :key=&quot;ind&quot;&gt;            &#123;&#123; val &#125;&#125;        &lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;btn&quot;&gt;下标1位置插入新来的&lt;/button&gt;&lt;/div&gt;\n\nexport default &#123;    data()&#123;        return &#123;            arr: [&#x27;老大&#x27;, &quot;老二&quot;, &#x27;老三&#x27;]        &#125;    &#125;,    methods: &#123;        btn()&#123;            // 索引为1的位置插入一个元素            this.arr.splice(1, 0, &#x27;新来的&#x27;)        &#125;    &#125;&#125;\n\n自定义指令\n自定义指令的目的是为标签添加额外的功能\n\n除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 v-xxx  \nhtml+css的复用的主要形式是组件\n你需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令\n注册\n目标: 获取标签, 扩展额外的功能\n\n全局注册在main.js用 Vue.directive()方法来进行注册, 以后随便哪个.vue文件里都可以直接用v-gfocus指令\n// 全局指令 - 到处&quot;直接&quot;使用Vue.directive(&quot;gfocus&quot;, &#123;  inserted(el) &#123; // 当绑定元素插入到父元素时调用    el.focus() // 触发标签的事件方法  &#125;,  update(el) &#123; // 值或模板更新时，触发此函数  &#125;&#125;)\n\n局部注册只能在当前组件.vue文件中使用\n&lt;script&gt;// 目标: 创建 &quot;自定义指令&quot;, 让输入框自动聚焦// 1. 创建自定义指令// 全局 / 局部// 2. 在标签上使用自定义指令  v-指令名export default &#123;    directives: &#123;        focus: &#123;            inserted(el)&#123; // 当绑定元素插入到父元素时调用                el.focus()            &#125;        &#125;    &#125;&#125;&lt;/script&gt;\n\n实际使用\n 目标: 创建 “自定义指令”, 让输入框自动聚焦\n\n自定义指令的两个事件：\n\ninserted方法 - 指令所在标签, 被插入到网页上触发(一次)\nupdate方法 - 指令对应数据/标签更新时, 此方法执行\n\n07_UseDirective.vue\n&lt;template&gt;  &lt;div&gt;      &lt;!-- &lt;input type=&quot;text&quot; v-gfocus&gt; --&gt;      &lt;input type=&quot;text&quot; v-focus&gt;        &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 创建 &quot;自定义指令&quot;, 让输入框自动聚焦// 1. 创建自定义指令// 全局 / 局部// 2. 在标签上使用自定义指令  v-指令名// 注意:// inserted方法 - 指令所在标签, 被插入到网页上触发(一次)// update方法 - 指令对应数据/标签更新时, 此方法执行export default &#123;    data()&#123;        return &#123;            colorStr: &#x27;red&#x27;        &#125;    &#125;,    directives: &#123;        focus: &#123;            inserted(el)&#123;                el.focus()            &#125;        &#125;    &#125;&#125;&lt;/script&gt;\n\n自定义指令传参\n目标: 使用自定义指令, 传入一个值\n\n语法：\n// 目标: 自定义指令传值Vue.directive(&#x27;自定义指令名&#x27;, &#123;  inserted(el, binding) &#123; // 当绑定元素插入到父元素时调用  &#125;,  update(el, binding) &#123; // 值或模板更新时，触发此函数  &#125;&#125;)\n\n需求: 定义color指令-传入一个颜色, 给标签设置文字颜色\nmain.js定义处修改一下\n// 目标: 自定义指令传值Vue.directive(&#x27;color&#x27;, &#123;  inserted(el, binding) &#123;    el.style.color = binding.value  &#125;,  update(el, binding) &#123;    el.style.color = binding.value  &#125;&#125;)\n\nUserDirect.vue处更改一下\n&lt;p v-color=&quot;colorStr&quot; @click=&quot;changeColor&quot;&gt;修改文字颜色&lt;/p&gt;&lt;script&gt;  data() &#123;    return &#123;      colorStr: &quot;red&quot;,    &#125;;  &#125;,  methods: &#123;    changeColor() &#123;      this.colorStr = &#x27;blue&#x27;;    &#125;,  &#125;,&lt;/script&gt;\n\nVue 过滤器filter定义使用\n目的: 转换格式, 过滤器就是一个函数, 传入值返回处理后的值\n简单理解就是在数据渲染到页面之前的过程中，进行一次包装处理\n\n注意：过滤器只能用在, 插值表达式和v-bind表达式\nVue中的过滤器场景：\n\n字母转大写, 输入”hello”, 输出”HELLO”\n字符串翻转, “输入hello, world”, 输出”dlrow ,olleh”\n\n语法: \n\nVue.filter(“过滤器名”, (值) =&gt; {return “返回处理后的值”})\nfilters: {过滤器名字: (值) =&gt; {return “返回处理后的值”}\n\n注意：一定要有返回值\n例子:\n\n全局定义字母都大写的过滤器\n局部定义字符串翻转的过滤器\n\n&lt;div&gt;    &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;!-- 2. 过滤器使用    语法: &#123;&#123; 值 | 过滤器名字 &#125;&#125;    --&gt;    &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; msg | toUp &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      msg: &#x27;Hello, Vue&#x27;    &#125;  &#125;,  // 方式2: 局部 - 过滤器  // 只能在当前vue文件内使用  /*     语法:      filters: &#123;       过滤器名字 (val) &#123;         return 处理后的值       &#125;     &#125;  */  filters: &#123;    toUp (val) &#123;      return val.toUpperCase()    &#125;  &#125;&#125;\n\nmain.js\n// 过滤器接参数Vue.filter(&quot;reverse&quot;, (val, s) =&gt; &#123;    return val.split(&quot;&quot;).reverse().join(s || &#x27;&#x27;)&#125;)\n\n传参和多过滤器\n可同时使用多个过滤器, 或者给过滤器传参\n从左往右依次过滤\n\n语法:\n\n过滤器传参:   vue变量 | 过滤器(实参) \n多个过滤器:   vue变量 | 过滤器1 | 过滤器2\n\n&lt;div&gt;    &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;!-- 1.      给过滤器传值      语法: vue变量 | 过滤器名(值)     --&gt;    &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse(&#x27;|&#x27;) &#125;&#125;&lt;/p&gt;    &lt;!-- 2.      多个过滤利使用      语法: vue变量 | 过滤器1 | 过滤器2     --&gt;    &lt;p&gt;&#123;&#123; msg | toUp | reverse(&#x27;|&#x27;) &#125;&#125;&lt;/p&gt;  &lt;/div&gt;\n\nVue 计算属性computed\n场景： 页面上某一个变量是由其他两个或多个变量通过一定的逻辑运算后得到的时候，可以用到计算属性进行简化\n\n基础语法语法:\ncomputed: &#123;    &quot;计算属性名&quot; () &#123;        return &quot;值&quot;    &#125;&#125;\n\n需求：求2个数的和显示到页面上\n&lt;div&gt;    &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      a: 10,      b: 20    &#125;  &#125;,  // 计算属性:  // 场景: 一个变量的值, 需要用另外变量计算而得来  /*    语法:    computed: &#123;      计算属性名 () &#123;        return 值      &#125;    &#125;  */ // 注意: 计算属性和data属性都是变量-不能重名 // 注意2: 函数内变量变化, 会自动重新计算结果返回  computed: &#123;    num()&#123;      return this.a + this.b    &#125;  &#125;&#125;\n\n总结：\n\n使用场景： 当变量的值, 需要通过别人计算而得来\n特点：函数内使用的变量改变, 重新计算结果返回\n注意事项：计算属性名和data里名字不能重复\n\ncomputed缓存\n目标: 计算属性是基于它们的依赖项的值结果进行缓存的，只要依赖的变量不变, 都直接从缓存取结果\n以上也是计算属性和方法的区别\n\n场景： 通过函数与计算属性做对比\n&lt;div&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\n\n\nexport default &#123;  data()&#123;    return &#123;      msg: &quot;Hello, Vue&quot;    &#125;  &#125;,  // 计算属性优势:  // 带缓存  // 计算属性对应函数执行后, 会把return值缓存起来  // 依赖项不变, 多次调用都是从缓存取值  // 依赖项值-变化, 函数会&quot;自动&quot;重新执行-并缓存新的值  computed: &#123;    reverseMessage()&#123;      console.log(&quot;计算属性执行了&quot;);      return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;)    &#125;  &#125;,  methods: &#123;    getMessage()&#123;      console.log(&quot;函数执行了&quot;);      return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;)    &#125;  &#125;&#125;\n\n小结：\n\n计算属性优势：\n带缓存 \n依赖项不变, 直接从缓存取\n依赖项改变, 函数自动执行并重新缓存\n\n\n 因为要消耗内存，所以也是计算属性的缺点\n\ncomputed的完整写法\n计算属性也是变量, 如果想要直接赋值, 需要使用完整写法\n场景： 当计算属性变量作为表单的值时\n注意事项：在实际开发过程中，几乎(99.9%)使用完整写法的计算属性，只有用在全选反选上\n\n语法：\ncomputed: &#123;    &quot;属性名&quot;: &#123;        set(值)&#123;                    &#125;,        get() &#123;            return &quot;值&quot;        &#125;    &#125;&#125;\n\n需求：让计算属性给v-model使用\n&lt;div&gt;    &lt;span&gt;姓名:&lt;/span&gt;    &lt;input type=&quot;text&quot; v-model=&quot;full&quot;&gt;&lt;/div&gt;\n\ncomputed: &#123;    data () &#123;        return &#123;            num1: 10,            num2: 20，            num3: 0        &#125;    &#125;,    full: &#123;        // 给full赋值触发set方法        set(val)&#123;            this.num3 = val        &#125;,        // 使用full的值触发get方法        get()&#123;            return this.num1 + this.num2        &#125;    &#125;&#125;\n\n小结：\n\n当需要给计算属性赋值时，会用到计算属性，但这种情况非常少。\nset函数和get函数的执行时机\nset接收要赋予的值\nget里要返回给这个计算属性具体值\n\n\n\nVue 侦听器watch\n可以侦听data/computed属性值改变\n\n​        一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。\n基本语法语法：\nwatch: &#123;    &quot;被侦听的属性名&quot; (newVal, oldVal)&#123;            &#125;&#125;\n\n例子：\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;obj.name&quot;&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      name: &quot;&quot;,      obj: &#123;        name: &#x27;&#x27;      &#125;    &#125;  &#125;,  // 目标: 侦听到name值的改变  /*  语法:    watch: &#123;      变量名 (newVal, oldVal)&#123;        // 变量名对应值改变这里自动触发      &#125;    &#125;  */  watch: &#123;    // newVal: 当前最新值    // oldVal: 上一刻值    name(newVal, oldVal)&#123;      console.log(newVal, oldVal);    &#125;,    // 监听引用类型    obj(newVal, oldVal) &#123;      console.log(newVal, oldVal)    &#125;  &#125;&#125;\n\n发现，引用类型的对象无法监听到，该怎么办?\n深度侦听和立即执行\n侦听引用数据类型, 或者立即执行侦听函数\n\n语法：\nwatch: &#123;    &quot;要侦听的属性名&quot;: &#123;        immediate: true, // 立即执行        deep: true, // 深度侦听复杂类型内变化        handler (newVal, oldVal) &#123;                    &#125;    &#125;&#125;\n\n例子：\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;user.age&quot;&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      user: &#123;        name: &quot;&quot;,        age: 0      &#125;    &#125;  &#125;,  // 目标: 侦听对象  /*  语法:    watch: &#123;      变量名 (newVal, oldVal)&#123;        // 变量名对应值改变这里自动触发      &#125;,      变量名: &#123;        handler(newVal, oldVal)&#123;        &#125;,        deep: true, // 深度侦听(对象里面层的值改变)        immediate: true // 立即侦听(网页打开handler执行一次)      &#125;    &#125;  */  watch: &#123;    user: &#123;      handler(newVal, oldVal)&#123;        // user里的对象        console.log(newVal, oldVal);      &#125;,      deep: true,      immediate: true    &#125;  &#125;&#125;\n\n\n总结: immediate立即侦听, deep深度侦听, handler固定方法触发\n\n补充： 另一种监听对象特定属性的方式​        通过设置key为对象属性的索引，value为监听回调方法的形式\nwatch: &#123;   &#x27;user.name&#x27;: (newVal, oldVal) =&gt; &#123;     console.log(newVal, oldVal)   &#125; &#125;\n\nVue组件为什么要用组件？同样的功能如果要复用的话，以前的方法是直接CV多份，显得代码非常的冗余和重复。\n使用vue提供的单vue文件 - 将某一小块会重复使用的代码封装到单独的vue文件中，以后通过直接使用这个文件来实现功能复用\n概念\n组件是可复用的 VUE 实例, 封装标签(HTML), 样式(CSS)和JS\n\n组件化 ：封装的思想，把页面上 可重用的部分 封装为 组件，从而方便项目的 开发 和 维护\n为什么说工作中写代码就是一个借鉴的过程呢: 一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为(html, css和js)\n\n基础使用\n目标: 每个组件都是一个独立的个体, 代码里体现为一个独立的.vue文件\n\n\n组件内template只能有一个根标签\n组件内data必须是一个函数, 独立作用域\n\n步骤:\n\n创建组件 components/Pannel.vue\n\n封装标签+样式+js - 组件都是独立的, 为了复用\n\n&lt;div&gt;    &lt;div class=&quot;title&quot;&gt;        &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt;        &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt;            &#123;&#123; isShow ? &quot;收起&quot; : &quot;展开&quot; &#125;&#125;        &lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt;        &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt;        &lt;p&gt;平明送客楚山孤。&lt;/p&gt;        &lt;p&gt;洛阳亲友如相问，&lt;/p&gt;        &lt;p&gt;一片冰心在玉壶。&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;\n\nexport default &#123;  data() &#123;    return &#123;      isShow: false,    &#125;;  &#125;,&#125;;\n\n&lt;style scoped&gt;.title &#123;  display: flex;  justify-content: space-between;  align-items: center;  border: 1px solid #ccc;  padding: 0 1em;&#125;.title h4 &#123;  line-height: 2;  margin: 0;&#125;.container &#123;  border: 1px solid #ccc;  padding: 0 1em;&#125;.btn &#123;  /* 鼠标改成手的形状 */  cursor: pointer;&#125;&lt;/style&gt;\n注册组件：创建后需要注册后再使用\n\n全局注册\n全局入口在main.js, 在new Vue之上注册\n// 目标: 全局注册 (一处定义到处使用)// 1. 创建组件 - 文件名.vue// 2. 引入组件import Pannel from &#x27;./components/Pannel&#x27;// 3. 全局 - 注册组件/*  语法:   Vue.component(&quot;组件名&quot;, 组件对象)*/Vue.component(&quot;PannelG&quot;, Pannel)\n\n全局注册PannelG组件名后, 就可以当做标签在任意Vue文件中template里用\n单双标签都可以或者小写加-形式, 运行后, 会把这个自定义标签当做组件解析, 使用\n==组件里封装的标签替换到这个位置==\n以下写法均可：\n&lt;PannelG&gt;&lt;/PannelG&gt;&lt;PannelG/&gt;&lt;pannel-g&gt;&lt;/pannel-g&gt;\n\n注意：\n\n如果组件在全局注册时，启动项目后初始化网页时就会立即加载该组件资源（无论是否在当前页面进行使用），那么这种情况是会导致网页开启缓慢的性能问题的，所以请在往后的开发过程中不要使用全局注册的方式\n关于引用组件的标签写法，这里建议如果import组件时采用的是驼峰命名法拼接的多个单词（如：PannelG），那么在创建标签的时候请用全小写并短横线隔开（如：pannel-g）\n\n\n局部 - 注册使用\n任意需要引用组件的 vue文件中中引入, 注册, 使用\n&lt;div id=&quot;app&quot;&gt;    &lt;h3&gt;案例：折叠面板&lt;/h3&gt;    &lt;!-- 4. 组件名当做标签使用 --&gt;    &lt;!-- &lt;组件名&gt;&lt;/组件名&gt; --&gt;    &lt;PannelG&gt;&lt;/PannelG&gt;    &lt;PannelL&gt;&lt;/PannelL&gt;&lt;/div&gt;\n\n// 目标: 局部注册 (用的多)// 1. 创建组件 - 文件名.vue// 2. 引入组件import Pannel from &#x27;./components/Pannel_1&#x27;export default &#123;    // 3. 局部 - 注册组件    /*        语法:         components: &#123;          &quot;组件名&quot;: 组件对象        &#125;    */    components: &#123;        PannelL: Pannel    &#125;,    /*          当标签名和import引入组件名称相同是可以简写    */    components: &#123;        Pannel    &#125;&#125;\n\n注意： 以后尽量将引入时（import）时的明明与当前注册组件时（components）的命名保持一致\n\n\n\n\n组件使用总结:\n\n(创建)封装html+css+vue到独立的.vue文件中\n(引入注册)组件文件 =&gt; 得到组件配置对象\n(使用)当前页面当做标签使用\n\nCSS中的scoped作用\n作用: 解决多个组件样式名相同, 冲突问题\n\n在style上加入scoped属性, 就会在此组件的标签上加上一个随机生成的data-v-hash开头的属性。保证了必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到\n&lt;style scoped&gt;&lt;/style&gt;\n\n\n解决了组件内部的css样式影响外部文件的问题\n总结: style上加scoped, 组件内的样式只在当前vue组件生效\nvue组件通信父传子 - props步骤：\n\n创建组件 components/MyProduct.vue\n\n&lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: ? &lt;/h3&gt;    &lt;p&gt;价格: ? 元&lt;/p&gt;    &lt;p&gt;描述: ?&lt;/p&gt;&lt;/div&gt;\n\n.my-product &#123;  width: 400px;  padding: 20px;  border: 2px solid #000;  border-radius: 5px;  margin: 10px;&#125;\n\n\n在父组件中注册MyProduct.vue子组件， 在使用时传入具体的数据\n\n&lt;div&gt;  &lt;!--     目标: 父(App.vue) -&gt; 子(MyProduct.vue) 分别传值进入    需求: 每次组件显示不同的数据信息    步骤(口诀):      1. 子组件 - props - 变量 (准备接收)      2. 父组件 - 传值进去   --&gt;  &lt;Product&gt;&lt;/Product&gt;&lt;/div&gt;\n\n// 1. 创建组件 (.vue文件)// 2. 引入组件import Product from &#x27;./components/MyProduct&#x27;export default &#123;  data()&#123;    return &#123;      str: &quot;好贵啊, 快来啊, 好吃&quot;    &#125;  &#125;,  // 3. 注册组件  components: &#123;    // Product: Product // key和value变量名同名 - 简写    Product  &#125;&#125;\n\n\n子组件内在props属性中定义变量, 用于接收外部传入的值\n\n&lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;    &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  props: [&#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;]&#125;\n\n\n父组件中的组件标签中传入不同的值\n注意: 传入的值，可以是固定值，也可以是变量\n\n\n&lt;div&gt;  &lt;!--     目标: 父(App.vue) -&gt; 子(MyProduct.vue) 分别传值进入    需求: 每次组件显示不同的数据信息    步骤(口诀):      1. 子组件 - props - 变量 (准备接收)      2. 父组件 - 传值进去   --&gt;  &lt;Product title=&quot;好吃的口水鸡&quot; price=&quot;50&quot; intro=&quot;开业大酬宾, 全场8折&quot;&gt;&lt;/Product&gt;  &lt;Product title=&quot;好可爱的可爱多&quot; price=&quot;20&quot; intro=&quot;老板不在家, 全场1折&quot;&gt;&lt;/Product&gt;  &lt;Product title=&quot;好贵的北京烤鸭&quot; price=&quot;290&quot; :intro=&quot;str&quot;&gt;&lt;/Product&gt;&lt;/div&gt;\n\n\n总结： 父传子的流程\n\n子组件内, props定义变量, 在子组件使用变量\n父组件内, 使用子组件, 属性方式给props变量传值\n\n\n要传的数据量较多时，也可以用v-for遍历循环，标签传递\n单项数据流概念： 从父到子的数据流向，叫做单项数据流\n在vue中需要遵循单向数据流原则\n1. 父组件的数据发生了改变，子组件会自动跟着变\n\n2. 子组件不能直接修改父组件传递过来的props  props是只读的\n（这里的只读，是栈内存中的数据只读，可以改堆）\n父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，\n对象是引用类型, 互相更新\n\n&lt;template&gt;  &lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;    &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;() =&gt; &#123;price--&#125;&quot;&gt;宝刀-砍1元&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n出现报错\n\n总结: props的值不能重新赋值, 对象引用关系属性值改变, 互相影响\n子传父 - $emit\n目标： 从子组件把值传出来给外面使用\n\n需求: 实现砍价功能, 子组件点击实现随机砍价-1功能\n语法：\n\n父: @自定义事件名=”父methods函数”\n&lt;MyProduct           v-for=&quot;(obj, i) in list&quot; :key=&quot;obj.id&quot;           :title=&quot;obj.proname&quot;           :price=&quot;obj.proprice&quot;           :intro=&quot;obj.info&quot;           @subprice=&quot;fn&quot;&gt;&lt;/MyProduct&gt;\n\nmethods: &#123;    fn()&#123;        // 逻辑代码 - 修改价格    &#125;&#125;\n子: this.$emit(“自定义事件名”, 传值) - 执行父methods里函数代码\n&lt;div class=&quot;my-product&quot;&gt;  &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;  &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;  &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;  &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt;&lt;/div&gt;\n\nimport eventBus from &#x27;../EventBus&#x27;export default &#123;  props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;],  methods: &#123;    subFn()&#123;      this.$emit(&#x27;subprice&#x27;) // 子向父    &#125;  &#125;&#125;\n如何知道是循环中的那个组件触发的砍价呢？\n\n为循环中的每一个组件设置它在数据列表中的索引号\n\n&lt;MyProduct           v-for=&quot;(obj, i) in list&quot; :key=&quot;obj.id&quot;           :title=&quot;obj.proname&quot;           :price=&quot;obj.proprice&quot;           :intro=&quot;obj.info&quot;           :index=&quot;i&quot;           @subprice=&quot;fn&quot;&gt;&lt;/MyProduct&gt;\n子组件调用父组件方法时，传入当前的索引\nexport default &#123;  props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;],  methods: &#123;    subFn()&#123;      this.$emit(&#x27;subprice&#x27;, this.index) // 子向父    &#125;  &#125;&#125;\n父组件实现砍价的js逻辑\nfn(inde)&#123;    // 逻辑代码    this.list[inde].proprice &gt; 1 &amp;&amp; (this.list[inde].proprice = (this.list[inde].proprice - 1).toFixed(2))&#125;\n\n\n总结: 父自定义事件和方法, 等待子组件触发事件给方法传值\n\n跨组件传参 - EventBus\n如果两个没有任何引入关系的组件，如何进行数据通信？\n\n例如：左侧为组件A，右侧为组件B，左右两侧的组件没人直接关联\n目标：如何听过左侧的砍价，修改右侧的组件中的值\n\n两个组件的关系非常的复杂，通过父子组件通讯是非常麻烦的。这时候可以使用通用的组件通讯方案：事件总线（event-bus)\n\n核心语法：\n\n设置EventBus/index.js- 定义事件总线bus对象\nimport Vue from &#x27;vue&#x27;// 导出空白vue对象export default new Vue()\nList.vue注册事件 - 等待接收要砍价的值 - 准备兄弟页面\n&lt;ul class=&quot;my-product&quot;&gt;    &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt;        &lt;span&gt;&#123;&#123; item.proname &#125;&#125;&lt;/span&gt;        &lt;span&gt;&#123;&#123; item.proprice &#125;&#125;&lt;/span&gt;    &lt;/li&gt;    &lt;li&gt;&#123;&#123;num&#125;&#125;&lt;/li&gt;&lt;/ul&gt;\n\n// 目标: 跨组件传值// 1. 引入空白vue对象(EventBus)// 2. 接收方 - $on监听事件import eventBus from &quot;../EventBus&quot;;export default &#123;    props: [&quot;arr&quot;],    data() &#123;        return &#123;            num: 0        &#125;    &#125;,&#125;;\n\n\n\n.my-product &#123;  width: 400px;  padding: 20px;  border: 2px solid #000;  border-radius: 5px;  margin: 10px;&#125;\ncomponents/MyProduct_sub.vue\n&lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;    &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt;&lt;/div&gt;\n\nimport eventBus from &#x27;../EventBus&#x27;export default &#123;  props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;],  methods: &#123;    subFn()&#123;      this.$emit(&#x27;subprice&#x27;, this.index, 1) // 子向父    &#125;  &#125;&#125;\n\n.my-product &#123;  width: 400px;  padding: 20px;  border: 2px solid #000;  border-radius: 5px;  margin: 10px;&#125;\n创建父组件，分别挂载以上两个组件\n\n发现组件A改变数据后，B的数据也会改变，为什么？\n\n&lt;div style=&quot;overflow: hidden;&quot;&gt;    &lt;div style=&quot;float: left;&quot;&gt;        &lt;MyProduct                   v-for=&quot;(obj, i) in list&quot;                   :key=&quot;obj.id&quot;                   :title=&quot;obj.proname&quot;                   :price=&quot;obj.proprice&quot;                   :intro=&quot;obj.info&quot;                   :index=&quot;i&quot;                   @subprice=&quot;fn&quot;                   &gt;&lt;/MyProduct&gt;    &lt;/div&gt;    &lt;div style=&quot;float: left;&quot;&gt;        &lt;List :arr=&quot;list&quot;&gt;&lt;/List&gt;    &lt;/div&gt;&lt;/div&gt;\n\nimport MyProduct from &quot;./components/MyProduct_sub&quot;;import List from &quot;./components/List&quot;;export default &#123;  data() &#123;    return &#123;      list: [        &#123;          id: 1,          proname: &quot;超级好吃的棒棒糖&quot;,          proprice: 18.8,          info: &quot;开业大酬宾, 全场8折&quot;,        &#125;,        &#123;          id: 2,          proname: &quot;超级好吃的大鸡腿&quot;,          proprice: 34.2,          info: &quot;好吃不腻, 快来买啊&quot;,        &#125;,        &#123;          id: 3,          proname: &quot;超级无敌的冰激凌&quot;,          proprice: 14.2,          info: &quot;炎热的夏天, 来个冰激凌了&quot;,        &#125;,      ],    &#125;;  &#125;,  components: &#123;    MyProduct,    List,  &#125;,  methods: &#123;    fn(i, price) &#123;      this.list[i].proprice &gt; 1 &amp;&amp;        (this.list[i].proprice = (this.list[i].proprice - price).toFixed(          2        ));    &#125;,  &#125;,&#125;; \n编写eventBus触发方 - MyProduct_sub.vue\nsubFn()&#123;    this.$emit(&#x27;subprice&#x27;, this.index, 1) // 子向父    eventBus.$emit(&quot;send&quot;, this.index, 1) // 跨组件&#125;\n编写eventBus接收方 - List.vue\n// 3. 组件创建完毕, 监听send事件created() &#123;    eventBus.$on(&quot;send&quot;, (index, price) =&gt; &#123;        this.arr[index].proprice &gt; 1 &amp;&amp;            (this.arr[index].proprice = (this.arr[index].proprice - price).toFixed(2));        this.num++    &#125;);&#125;\n\n\n 总结: eventBus是空的Vue对象, 只负责$on注册事件, $emit触发事件, 一定要确保$on先执行\n\n扩展 props的进阶用法说明：props也可以作为一个对象，并且可以指定数据类型，必要性，默认值\n语法：\nexport default &#123;\tprops: &#123;        a: &#123;            type: String, // 传参类型            required: true, // 是否必传（一般也不写，了解）            default: &#x27;string&#x27; // 默认值        &#125;,        b: &#123;            type: Array,            default: () =&gt; []        &#125;,        c: &#123;            type: Object,            default: () =&gt; (&#123;&#125;)        &#125;    &#125;&#125;;\n\n动态组件\n目标: 多个组件使用同一个挂载点，并动态切换，这就是动态组件\n\n&lt;template&gt;  &lt;div&gt;      &lt;button&gt;账号密码填写&lt;/button&gt;      &lt;button&gt;个人信息填写&lt;/button&gt;      &lt;p&gt;下面显示注册组件-动态切换:&lt;/p&gt;      &lt;div style=&quot;border: 1px solid red;&quot;&gt;          &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;      &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 动态组件 - 切换组件显示// 场景: 同一个挂载点要切换 不同组件 显示// 1. 创建要被切换的组件 - 标签+样式// 2. 引入到要展示的vue文件内, 注册// 3. 变量-承载要显示的组件名// 4. 设置挂载点&lt;component :is=&quot;变量&quot;&gt;&lt;/component&gt;// 5. 点击按钮-切换comName的值为要显示的组件名import UserName from &#x27;../components/01/UserName&#x27;import UserInfo from &#x27;../components/01/UserInfo&#x27;export default &#123;    data()&#123;        return &#123;            comName: &quot;UserName&quot; // 这个值一定要是我们的组件名        &#125;    &#125;,    components: &#123;        UserName,        UserInfo    &#125;&#125;&lt;/script&gt;\n\n总结：vue内置component组件，配合is属性，设置要显示的组件名称\n组件缓存\n目标: 组件切换会导致组件被频繁销毁和重新创建, 性能不好\n\n使用Vue内置的keep-alive组件, 可以让包裹的组件保存在内存中不被销毁\n演示1:  可以先给UserName.vue和UserInfo.vue 注册created和destroyed生命周期事件, 观察创建和销毁过程\n每一次切换，都会创建A，并销毁B\nApp.vue\n&lt;hr&gt;&lt;h1&gt;2. 组件缓存&lt;/h1&gt;&lt;UseDynamic2&gt;&lt;/UseDynamic2&gt;\n\nUserName.vue\n&lt;script&gt;export default &#123;    created()&#123;        console.log(&quot;02-UserName-创建&quot;);    &#125;,    destroyed()&#123;        console.log(&quot;02-UserName-销毁&quot;);    &#125;,&#125;&lt;/script&gt;\n\n\n\n演示2: 使用keep-alive内置的vue组件, 让动态组件缓存而不是销毁\n除了第一次开启组件时会创建，切换的过程当中不会重复创建和销毁的过程\n语法:\n​        Vue内置的keep-alive组件 包起来要频繁切换的组件\n02_UseDynamic.vue\n&lt;div style=&quot;border: 1px solid red;&quot;&gt;    &lt;!-- Vue内置keep-alive组件, 把包起来的组件缓存起来 --&gt;    &lt;keep-alive&gt;        &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;/div&gt;\n\nkeep-alive相关钩子函数\n目标: 被缓存的组件不再创建和销毁, 而是激活和非激活\n\n补充生命周期:\n\nactivated - 激活\ndeactivated - 失去激活状态\n\n\n总结: keep-alive可以提高组件的性能, 内部包裹的标签不会被销毁和重新创建, 触发激活和非激活的生命周期方法\n\nUserName.vue\n&lt;script&gt;export default &#123;    created()&#123;        console.log(&quot;02-UserName-创建&quot;);    &#125;,    destroyed()&#123;        console.log(&quot;02-UserName-销毁&quot;);    &#125;,    // 组件缓存下 - 多了2个钩子函数    activated()&#123;        console.log(&quot;02-UserName-激活&quot;);    &#125;,    deactivated()&#123;        console.log(&quot;02-UserName-失去激活&quot;);    &#125;&#125;&lt;/script&gt;\n\n组件插槽\n给组件传递动态的参数时，可以使用props，那如果给组件传递动态的标签结构呢？\n\n基本用法\n目标: 用于实现组件的内容分发, 通过 slot 标签, 可以接收到写在组件标签内的内容\n\nvue提供组件插槽能力, 允许开发者在封装组件时，把不确定的部分定义为插槽\n需求: 折叠面板案例, 想要实现不同内容显示, 我们把折叠面板里的Pannel组件, 添加组件插槽方式\n\n语法口诀: \n\n组件内用&lt;slot&gt;&lt;/slot&gt;占位\n使用组件时&lt;Pannel&gt;&lt;/Pannel&gt;夹着的地方, 传入标签替换slot\n\n03/Pannel.vue - 组件\n&lt;template&gt;  &lt;div&gt;    &lt;!-- 按钮标题 --&gt;    &lt;div class=&quot;title&quot;&gt;      &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt;      &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt;        &#123;&#123; isShow ? &quot;收起&quot; : &quot;展开&quot; &#125;&#125;      &lt;/span&gt;    &lt;/div&gt;    &lt;!-- 下拉内容 --&gt;    &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt;          &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt;          &lt;p&gt;平明送客楚山孤。&lt;/p&gt;          &lt;p&gt;洛阳亲友如相问，&lt;/p&gt;          &lt;p&gt;一片冰心在玉壶。&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\n\n\nexport default &#123;  data() &#123;    return &#123;      isShow: false,    &#125;;  &#125;,&#125;;\n\nh3 &#123;  text-align: center;&#125;.title &#123;  display: flex;  justify-content: space-between;  align-items: center;  border: 1px solid #ccc;  padding: 0 1em;&#125;.title h4 &#123;  line-height: 2;  margin: 0;&#125;.container &#123;  border: 1px solid #ccc;  padding: 0 1em;&#125;.btn &#123;  /* 鼠标改成手的形状 */  cursor: pointer;&#125;img &#123;  width: 50%;&#125;\n\n步骤：\n\n在 views/03_UserSlot.vue 中使用组件\n03_UserSlot.vue\n&lt;div id=&quot;container&quot;&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;h3&gt;案例：折叠面板&lt;/h3&gt;        &lt;Pannel&gt;&lt;/Pannel&gt;        &lt;Pannel&gt;&lt;/Pannel&gt;        &lt;Pannel&gt;&lt;/Pannel&gt;    &lt;/div&gt;&lt;/div&gt;\n\nimport Pannel from &quot;../components/03/Pannel&quot;;export default &#123;  components: &#123;    Pannel,  &#125;,&#125;;\n\n#app &#123;  width: 400px;  margin: 20px auto;  background-color: #fff;  border: 4px solid blueviolet;  border-radius: 1em;  box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.5);  padding: 1em 2em 2em;&#125;\n给Pannel.vue设置插槽\n&lt;template&gt;  &lt;div&gt;    &lt;!-- 按钮标题 --&gt;    &lt;div class=&quot;title&quot;&gt;      &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt;      &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt;        &#123;&#123; isShow ? &quot;收起&quot; : &quot;展开&quot; &#125;&#125;      &lt;/span&gt;    &lt;/div&gt;    &lt;!-- 下拉内容 --&gt;    &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt;      &lt;!-- 插槽设置位置，这里可以插入html结构 --&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n```html\n\n  \n    \n      案例：折叠面板\n      \n        \n        我是内容\n      \n      \n        寒雨连江夜入吴,\n        平明送客楚山孤。\n        洛阳亲友如相问，\n        一片冰心在玉壶。\n      \n      \n    \n  \n\n### 插槽默认内容&gt; 目标: 如果外面不给传, 想给个默认显示内容口诀:  `&lt;slot&gt;`夹着内容默认显示内容, 如果不给插槽slot传东西, 则使用`&lt;slot&gt;`夹着的内容在原地显示Pannel.vue```html&lt;template&gt;  &lt;div&gt;    &lt;!-- 按钮标题 --&gt;    &lt;div class=&quot;title&quot;&gt;      &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt;      &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt;        &#123;&#123; isShow ? &quot;收起&quot; : &quot;展开&quot; &#125;&#125;      &lt;/span&gt;    &lt;/div&gt;    &lt;!-- 下拉内容 --&gt;    &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt;      &lt;!-- 插槽设置位置，这里可以插入html结构 --&gt;      &lt;slot&gt;默认显示的内容&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\n如果有两个同地方都需要插入HTML结构呢？该怎么办？\n具名插槽\n目标: 当一个组件内有2处以上需要外部传入标签的地方，传入的标签可以分别派发给不同的slot位置\n\n语法：\n\nslot使用name属性区分插槽名称\nPannel.vue\n&lt;template&gt;  &lt;div&gt;    &lt;!-- 按钮标题 --&gt;    &lt;div class=&quot;title&quot;&gt;      &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;      &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt;        &#123;&#123; isShow ? &quot;收起&quot; : &quot;展开&quot; &#125;&#125;      &lt;/span&gt;    &lt;/div&gt;    &lt;!-- 下拉内容 --&gt;    &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt;     &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\ntemplate配合v-slot: 来分别对应插槽标签\n注意：\n\nv-slot一般用跟template标签使用 (template是html5新出标签内容模板元素, 不会渲染到页面上, 一般被vue解析内部标签)\nv-slot的简写是#\n\nviews/04_UseSlot.vue使用\n&lt;template&gt;  &lt;div id=&quot;container&quot;&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;h3&gt;案例：折叠面板&lt;/h3&gt;      &lt;Pannel&gt;        &lt;!-- v-slot插槽名称 --&gt;        &lt;template v-slot:title&gt;          &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt;        &lt;/template&gt;        &lt;template v-slot:content&gt;          &lt;img src=&quot;../assets/mm.gif&quot; alt=&quot;&quot;&gt;          &lt;span&gt;我是内容&lt;/span&gt;        &lt;/template&gt;      &lt;/Pannel&gt;      &lt;Pannel&gt;        &lt;!-- 简写方式 --&gt;        &lt;template #title&gt;          &lt;span style=&quot;color: red;&quot;&gt;我是标题&lt;/span&gt;        &lt;/template&gt;        &lt;template #content&gt;          &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt;          &lt;p&gt;平明送客楚山孤。&lt;/p&gt;          &lt;p&gt;洛阳亲友如相问，&lt;/p&gt;          &lt;p&gt;一片冰心在玉壶。&lt;/p&gt;        &lt;/template&gt;      &lt;/Pannel&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\nimport Pannel from &quot;../components/04/Pannel&quot;;export default &#123;  components: &#123;    Pannel,  &#125;,&#125;;\n\n在使用插槽时，是否可以使用子组件中的变量呢？\n作用域插槽 - 接收 prop 的具名插槽\n目标: 子组件里值, 在给插槽赋值时在父组件环境下使用\n\n口诀: \n\n子组件, 在slot上绑定属性和子组件内的值\n使用组件, 传入自定义标签, 用template和v-slot=”自定义变量名” \nscope变量名自动绑定slot上所有属性和值\n\n场景： 插槽有显示默认内容，但使用时，不使用外部传参，只用组件本身的内容去修改页面内容\n需求：在该组件内，不改动代码的基础上，能否使用defaultTwo替换插值中的默认值\ncomponents/05/Pannel.vue \n&lt;template&gt;  &lt;div&gt;    &lt;!-- 按钮标题 --&gt;    &lt;div class=&quot;title&quot;&gt;      &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt;      &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt;        &#123;&#123; isShow ? &quot;收起&quot; : &quot;展开&quot; &#125;&#125;      &lt;/span&gt;    &lt;/div&gt;    &lt;!-- 下拉内容 --&gt;    &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt;     &lt;!-- 这里!!!!!!!!!!!! --&gt;      &lt;slot :row=&quot;defaultObj&quot; name=&quot;pannel&quot;&gt;         &#123;&#123; defaultObj.defaultOne &#125;&#125;     &lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\n// 目标: 作用域插槽// 场景: 使用插槽, 使用组件内的变量// 1. slot标签, 自定义属性和内变量关联// 2. 使用组件, template配合v-slot=&quot;变量名&quot;// 变量名会收集slot身上属性和值形成对象export default &#123;  data() &#123;    return &#123;      isShow: false,      defaultObj: &#123;        defaultOne: &quot;无名氏&quot;,        defaultTwo: &quot;咕咕&quot;      &#125;    &#125;;  &#125;,&#125;;\n\n在调用子组件处05_UseSlot.vue引用子组件中solt上的设置的属性\n\n&lt;template&gt;  &lt;div id=&quot;container&quot;&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;h3&gt;案例：折叠面板&lt;/h3&gt;      &lt;Pannel&gt;        &lt;!-- 需求: 插槽时, 使用组件内变量 --&gt;        &lt;!-- scope变量: &#123;row: defaultObj&#125; --&gt;        &lt;template v-slot:pannel=&quot;scope&quot;&gt;          &lt;p&gt;&#123;&#123; scope.row.defaultTwo &#125;&#125;&lt;/p&gt;        &lt;/template&gt;      &lt;/Pannel&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Pannel from &quot;../components/05/Pannel&quot;;export default &#123;  components: &#123;    Pannel,  &#125;,&#125;;&lt;/script&gt;\n\n\n总结: 组件内变量绑定在slot上, 然后使用组件v-slot=”变量”  变量上就会绑定slot身上属性和值\n\nVue生命周期生命周期\n一个vue组件从 创建 到 销毁 的整个过程就是生命周期\n\n\n钩子函数\n目标: Vue 框架内置函数，随着组件的生命周期阶段，自动执行\n\n作用: 特定的时间点，执行特定的操作\n场景: 组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据\n分类: 4大阶段8个方法\n\n初始化\n挂载\n更新\n销毁\n\n\n\n\n阶段\n方法名\n方法名\n\n\n\n初始化\nbeforeCreate\ncreated\n\n\n挂载\nbeforeMount\nmounted\n\n\n更新\nbeforeUpdate\nupdated\n\n\n销毁\nbeforeDestroy\ndestroyed\n\n\n\n初始化阶段含义讲解:\n1.new Vue() – Vue实例化(组件也是一个小的Vue实例)\n2.Init Events &amp; Lifecycle – 初始化事件和生命周期函数\n3.beforeCreate – 生命周期钩子函数被执行\n4.Init injections&amp;reactivity – Vue内部添加data和methods等\n5.created – 生命周期钩子函数被执行, 实例创建\n6.接下来是编译模板阶段 –开始分析\nmain.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  // el: &quot;#app&quot;, // vue实例编译后的模板挂载到index.html的id叫app的标签上  render: h =&gt; h(App),&#125;).$mount(&quot;#app&quot;)\n\n创建components/Life.vue文件，并且在App.vue里引入\n&lt;div&gt;    &lt;h1&gt;1. 生命周期&lt;/h1&gt;    &lt;Life&gt;&lt;/Life&gt;&lt;/div&gt;\n\nimport Life from &#x27;./components/Life&#x27;export default &#123;  components: &#123;    Life  &#125;&#125;\n\n设置components/Life.vue文件内容\n&lt;div&gt;    &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt;    &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\n\n\nexport default &#123;     data()&#123;         return &#123;             msg: &quot;hello, Vue&quot;,         &#125;     &#125;,     // 一. 初始化     // new Vue()以后, vue内部给实例对象添加了一些属性和方法,     // data和methods初始化&quot;之前&quot;     beforeCreate()&#123;         console.log(&quot;beforeCreate -- 执行&quot;);         console.log(this.msg); // undefined     &#125;     // data和methods初始化以后     // 场景: 网络请求, 注册全局事件     created()&#123;         console.log(&quot;created -- 执行&quot;);         console.log(this.msg); // hello, Vue     &#125; &#125;\n\n\n挂载阶段1.template选项检查\n​    有 - 编译template返回render渲染函数\n​    无 – 编译el选项对应标签作为template(要渲染的模板)（非脚手架）\n2.虚拟DOM挂载成真实DOM之前\n3.beforeMount – 生命周期钩子函数被执行\n4.Create … – 把虚拟DOM和渲染的数据一并挂到真实DOM上\n5.真实DOM挂载完毕\n6.mounted – 生命周期钩子函数被执行\ncomponents/Life.vue 中设置beforeMount和mounted\n&lt;div&gt;    &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt;    &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\n\n\nexport default &#123;    // ...省略其他代码        // 二. 挂载    // 真实DOM挂载之前    // 场景: 预处理data, 不会触发updated钩子函数    beforeMount()&#123;        console.log(&quot;beforeMount -- 执行&quot;);        console.log(document.getElementById(&quot;myP&quot;)); // null        this.msg = &quot;重新值&quot;    &#125;,    // 真实DOM挂载以后    // 场景: 挂载后真实DOM    mounted()&#123;        console.log(&quot;mounted -- 执行&quot;);        console.log(document.getElementById(&quot;myP&quot;)); // p    &#125;&#125;\n\n\n注意：\n\n一般工作中主要会用到created和mounted这两个生命周期。\n可以在created中修改data中的数据，以及注册全局事件，不可以去查询DOM元素\n可以在mounted中做所有created中可以执行的事件，也可以在这个时期去查询DOM元素\n以上 - 可以直接只用mounted确保万无一失\n\n\n\n更新阶段含义讲解:\n1.当data里数据改变, 更新DOM之前\n2.beforeUpdate – 生命周期钩子函数被执行\n3.Virtual DOM…… – 虚拟DOM重新渲染, 打补丁到真实DOM\n4.updated – 生命周期钩子函数被执行\n5.当有data数据改变 – 重复这个循环\ncomponents/Life.vue 中设置beforeUpdate和updated\n准备ul+li循环, 按钮添加元素, 触发data改变-&gt;导致更新周期开始\n&lt;div&gt;    &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt;    &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;ul id=&quot;myUL&quot;&gt;        &lt;li v-for=&quot;(val, index) in arr&quot; :key=&quot;index&quot;&gt;            &#123;&#123; val &#125;&#125;        &lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;arr.push(1000)&quot;&gt;点击末尾加值&lt;/button&gt;&lt;/div&gt;\n\n\n\nexport default &#123;    data()&#123;        return &#123;            msg: &quot;hello, Vue&quot;,            arr: [5, 8, 2, 1]        &#125;    &#125;,    // ...省略其他代码    // 三. 更新    // 前提: data数据改变才执行    // 更新之前    beforeUpdate() &#123;        console.log(&quot;beforeUpdate -- 执行&quot;);        console.log(document.querySelectorAll(&quot;#myUL&gt;li&quot;)[4]); // undefined    &#125;,    // 更新之后    // 场景: 获取更新后的真实DOM    updated() &#123;        console.log(&quot;updated -- 执行&quot;);        console.log(document.querySelectorAll(&quot;#myUL&gt;li&quot;)[4]); // li    &#125;,&#125;\n\n\n问：\n\n什么时候执行updated钩子函数?\n当数据发生变化并更新页面后\n\n在哪可以获取更新后的DOM?\n在updated钩子函数里\n\n\n注意：\n\n更新阶段有这样一种情景：如果在update更新阶段时对数据做了新的处理，可能又会触发update更新阶段，以此往复会出现修改一次数据触发多次更新阶段逻辑的过程，这样会出现项目代码执行效率低下，在开发过程中，尽量不要去使用update的两个生命周期，如果需要监听某个值的改变应该用到watch！\n\n销毁阶段含义讲解:\n1.当$destroy()被调用 – 比如组件DOM被移除(例v-if)\n2.beforeDestroy – 生命周期钩子函数被执行\n3.拆卸数据监视器、子组件和事件侦听器\n4.实例销毁后, 最后触发一个钩子函数\n5.destroyed – 生命周期钩子函数被执行\ncomponents/Life.vue - 准备生命周期方法(Life组件即将要被删除)\nexport default &#123;    // ...省略其他代码    created() &#123;        // ...省略其他代码        this.timer = setInterval(() =&gt; &#123;            console.log(&quot;哈哈哈&quot;);        &#125;, 1000)    &#125;,        // 四. 销毁    // 前提: v-if=&quot;false&quot; 销毁Vue实例    // 场景: 移除全局事件, 移除当前组件, 计时器, 定时器    beforeDestroy()&#123;        // console.log(&#x27;beforeDestroy -- 执行&#x27;);        clearInterval(this.timer)    &#125;,    destroyed()&#123;        // console.log(&quot;destroyed -- 执行&quot;);    &#125;&#125;\n\nApp.vue - 点击按钮让Life组件从DOM上移除 -&gt; 导致Life组件进入销毁阶段\n&lt;div&gt;  &lt;h1&gt;1. 生命周期&lt;/h1&gt;  &lt;Life v-if=&quot;show&quot;&gt;&lt;/Life&gt;  &lt;button @click=&quot;show = false&quot;&gt;销毁组件&lt;/button&gt;&lt;/div&gt;\n\n\n\nimport Life from &#x27;./components/Life&#x27;export default &#123;    data()&#123;        return &#123;            show: true        &#125;    &#125;,&#125;\n\n注意：\n\n销毁阶段一般是拿来销毁一些全局事件, 移除当前组件, 计时器, 定时器，特别注意！如果子组件中涉及到定时器setInterval时，一定注意当组件销毁时这个定时器是否关闭clearInterval\n\n总结常用的生命周期钩子：\n1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。     2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。 \n关于销毁Vue实例     \n1.销毁后借助Vue开发者工具看不到任何信息。     \n2.销毁后自定义事件会失效，但原生DOM事件依然有效。     \n3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\nVue实例的方法$refs - 获取DOM元素\n目标: 利用 ref 和 $refs 可以用于获取 dom 元素\n\n步骤：\n\n创建components/More.vue,设置基本结构\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;&lt;/div&gt;\n\n// 目标: 获取组件对象export default &#123;&#125;\nApp.vue引入 组件\n&lt;div&gt;    &lt;h1&gt;1. 生命周期&lt;/h1&gt;    &lt;Life v-if=&quot;show&quot;&gt;&lt;/Life&gt;    &lt;button @click=&quot;show = false&quot;&gt;销毁组件&lt;/button&gt;    &lt;hr&gt;    &lt;h1&gt;2. axios使用&lt;/h1&gt;    &lt;UseAxios&gt;&lt;/UseAxios&gt;    &lt;hr&gt;    &lt;h1&gt;3. $refs的使用&lt;/h1&gt;    &lt;More&gt;&lt;/More&gt;&lt;/div&gt;\n\nimport More from &#x27;./components/More&#x27;export default &#123;    components: &#123;        More    &#125;&#125;\n给标签设置ref属性\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;&lt;/div&gt;\n\n\n\n// 目标: 获取组件对象   // 组件起别名ref   export default &#123;   &#125;\n获取组件对象\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;&lt;/div&gt;\n\n// 目标: 获取组件对象// 组件起别名ref// 恰当时机, 获取组件对象 - mountedexport default &#123;    mounted()&#123;        console.log(document.getElementById(&quot;h&quot;)); // h1        console.log(this.$refs.myH); // h1\t&#125;,&#125;\n\n$refs - 获取组件对象\n通过$refs 可以获取整个组件对象，并且使用该组件中的数据与方法\n\n步骤：\n\n创建components/Child/Demo.vue，组件\n&lt;div&gt;    &lt;p&gt;我是Demo组件&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;    methods: &#123;        fn()&#123;            console.log(&quot;demo组件内的方法被调用了&quot;);        &#125;    &#125;&#125;\n在More.vue中 - 获取组件对象并设置ref属性\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;    &lt;p&gt;2. 获取组件对象 - 可调用组件内一切&lt;/p&gt;    &lt;Demo ref=&quot;de&quot;&gt;&lt;/Demo&gt;&lt;/div&gt;\n\n// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123;    mounted()&#123;        console.log(document.getElementById(&quot;h&quot;)); // h1        console.log(this.$refs.myH); // h1    &#125;,    components: &#123;        Demo    &#125;&#125;\n使用$refs调用组件中的方法\n// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123;    mounted()&#123;        console.log(document.getElementById(&quot;h&quot;)); // h1        console.log(this.$refs.myH); // h1        let demoObj = this.$refs.de;        demoObj.fn()    &#125;,    components: &#123;        Demo    &#125;&#125;\n\n\n总结: ref定义值, 通过$refs.值 来获取组件对象, 就能继续调用组件内的变量\n\n$nextTick使用\nVue更新DOM-异步的!（数据与页面有延时）\n\n\n案例：点击count++, 马上通过”原生DOM”拿标签内容, 无法拿到新值\n\n步骤：\n\n在 components/Move.vue 中添加以下代码\n&lt;div&gt;    &lt;p&gt;3. vue更新DOM是异步的&lt;/p&gt;    &lt;p ref=&quot;myP&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;btn&quot;&gt;点击count+1, 马上提取p标签内容&lt;/button&gt;&lt;/div&gt;\n\nimport Demo from &#x27;./Child/Demo&#x27;export default &#123;    methods: &#123;        btn()&#123;            this.count++; // vue监测数据更新, 开启一个DOM更新队列(异步任务)            console.log(this.$refs.myP.innerHTML); // 0        &#125;    &#125;&#125;\n\n发现： 页面数据更改了，但从页面上拿到的dom元素中的值还是更改前的数据\n\n使用$nextTick()\n等DOM更新后，触发$nextTick()的函数体执行\n&lt;div&gt;    &lt;p&gt;3. vue更新DOM是异步的&lt;/p&gt;    &lt;p ref=&quot;myP&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;btn&quot;&gt;点击count+1, 马上提取p标签内容&lt;/button&gt;&lt;/div&gt;\n\nimport Demo from &#x27;./Child/Demo&#x27;export default &#123;    methods: &#123;        btn()&#123;            this.count++; // vue监测数据更新, 开启一个DOM更新队列(异步任务)            // console.log(this.$refs.myP.innerHTML); // 0            // 原因: Vue更新DOM异步            // 解决: this.$nextTick()            // 过程: DOM更新完会挨个触发$nextTick里的函数体            this.$nextTick(() =&gt; &#123;                console.log(this.$refs.myP.innerHTML); // 1            &#125;)        &#125;    &#125;&#125;\n\nVue路由路由是一对一的映射关系，vue中的路由是路径和组件的映射关系，通过路径的不同在页面上展示不同的组件\n为什么使用路由\n目标: 在一个页面里, 切换业务场景，不会刷新\n\n具体使用示例: 网易云音乐 https://music.163.com/\n单页面应用(SPA):  所有功能在一个html页面上实现\n前端路由作用: 实现业务场景切换\n优点：\n\n整体不刷新页面，用户体验更好\n\n数据传递容易, 开发效率高\n\n\n缺点：\n\n首次加载会比较慢一点。不利于seo（搜索引擎优化）\n\n总结：\n\n单页面应用： 所有业务都在一个页面上编写，只有一个html\n通过路由来切换单页面的业务场景\n\nvue-router介绍\n目标: 如何在Vue项目中集成路由\n\n官网: https://router.vuejs.org/zh/\n\nvue-router模块包\n\n它和 Vue.js 深度集成\n可以定义 - 视图表(映射规则)\n\n\n模块化的\n\n提供2个内置全局组件（router-link，router-view）\n\n声明式导航自动激活的 CSS class 的链接\n\n\n组件分类\n目标:  .vue文件分2类, 一个是页面组件, 一个是复用组件\n\nsrc/views(或pages) 文件夹 和 src/components文件夹\n\n页面组件 - 页面展示 - 配合路由用\n复用组件 - 展示数据/常用于复用\n\n\n\n总结: views下的页面组件, 配合路由切换, components下的一般引入到views下的vue中复用展示数据\n\nvue-router使用\n需求： 通过切换不同的路由链接，来实现内容页面的切换\nApp.vue - 页面标签和样式准备\n分析：\n\n下载vue-router模块到当前项目\n在main.js中引入VueRouter函数\n在Vue.use()上，添加全局RouterLink和RouterView组件\n创建路由规则数组（路由结构） - 保证路径和组件名称一一对应\n利用规则生产路由对象\n把路由对象注入到new Vue实例中\n用router-view作为挂载点，切换不同的路由页面\nvue-router文档\n\n步骤：\n\n安装\n// 1. 下载vue-routeryarn add vue-router@3.5.1\n在main.js 中导入路由\n// 2. 引入import VueRouter from &#x27;vue-router&#x27;\n使用路由插件\n// 在vue中，使用使用vue的插件，都需要调用Vue.use()// 3. 注册全局组件Vue.use(VueRouter)\n创建路由规则数组\nimport Find from &#x27;./views/Find.vue&#x27; // @是src的绝对地址import My from &#x27;./views/My.vue&#x27;import Part from &#x27;./views/Part.vue&#x27;// 4. 规则数组const routes = [  &#123;    path: &quot;/find&quot;, // 路由    component: Find // 组件名称  &#125;,  &#123;    path: &quot;/my&quot;,    component: My  &#125;,  &#123;    path: &quot;/part&quot;,    component: Part  &#125;]\n\nFind.vue\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;推荐&lt;/p&gt;    &lt;p&gt;排行榜&lt;/p&gt;    &lt;p&gt;歌单&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n\nMy.vue\n&lt;template&gt;  &lt;div&gt;      &lt;p&gt;我的收藏&lt;/p&gt;      &lt;p&gt;我的历史记录&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n\nPart.vue\n&lt;template&gt;  &lt;div&gt;      &lt;p&gt;关注明星&lt;/p&gt;      &lt;p&gt;发现精彩&lt;/p&gt;      &lt;p&gt;寻找伙伴&lt;/p&gt;      &lt;p&gt;加入我们&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n创建路由对象 -  传入规则\n// 5. 生成路由对象（传入配置对象）const router = new VueRouter(&#123;  routes,// routes是固定key(传入规则数组)&#125;)\n关联到vue实例\nnew Vue(&#123;  router&#125;)\n设置App.vue引入挂载路由组件\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a&gt;      &lt;a href=&quot;#/my&quot;&gt;我的音乐&lt;/a&gt;      &lt;a href=&quot;#/part&quot;&gt;朋友&lt;/a&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;!-- 7. 设置挂载点-当url的hash值路径切换, 显示规则里对应的组件到这 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;.footer_wrap &#123;  position: fixed;  left: 0;  top: 0;  display: flex;  width: 100%;  text-align: center;  background-color: #333;  color: #ccc;&#125;.footer_wrap a &#123;  flex: 1;  text-decoration: none;  padding: 20px 0;  line-height: 20px;  background-color: #333;  color: #ccc;  border: 1px solid black;&#125;.footer_wrap a:hover &#123;  background-color: #555;&#125;.top &#123;  padding-top: 62px;&#125;&lt;/style&gt;\n\n\n总结: \n\n下载路由模块, 编写对应规则注入到vue实例上, 使用router-view挂载点显示切换的路由\n\n一切都围绕着hash值变化为准,切换url上的hash值，开始匹配规则，对应组件展示到router-view位置\n\n\n\n声明式导航基础用法\n可用全局组件router-link来替代a标签\n\n\n vue-router提供了一个全局组件 router-link\n router-link实质上最终会渲染成a链接 to属性等价于提供 href属性**(to无需#)**\n router-link提供了声明式导航高亮的功能(自带类名)\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;      &lt;router-link to=&quot;/part&quot;&gt;朋友&lt;/router-link&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    // 目标: 声明式导航 - 基础使用    // 本质: vue-router提供的全局组件 &quot;router-link&quot;替代a标签    // 1. router-link 替代a标签    // 2. to属性      替代href属性    // 好处: router-link自带高亮的类名(激活时类名)    // 3. 对激活的类名做出样式的编写    export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;/* 省略了 其他样式 */.footer_wrap .router-link-active&#123;  color: white;  background: black;&#125;&lt;/style&gt;\n\n\n 总结: \n\nrouter-link是全局组成的组件，本质就是a标签\n当使用router-link时，必须传入to属性，指定路由路径值\n自带类名\n\n router-link没啥大用\n\n跳转传参\n目标: 在跳转路由时, 可以给路由对应的组件内传值\n\n在router-link上的to属性传值, 语法格式如下\n\n/path?参数名=值\n/path/值 – 需要路由对象提前配置 path: “/path/参数名”\n\n对应页面组件接收传递过来的值\n\n$route.query.参数名\n$route.params.参数名\n\n步骤：\n\n路由定义\n&#123;    path: &quot;/part&quot;,    component: Part&#125;,&#123;    path: &quot;/part/:username&quot;, // 有:的路径代表要接收具体的值    component: Part&#125;,\n修改Part.vue中接受的路由参数\n&lt;template&gt;  &lt;div&gt;      &lt;p&gt;关注明星&lt;/p&gt;      &lt;p&gt;发现精彩&lt;/p&gt;      &lt;p&gt;寻找伙伴&lt;/p&gt;      &lt;p&gt;加入我们&lt;/p&gt;      &lt;p&gt;人名: &#123;&#123; $route.query.name &#125;&#125; -- &#123;&#123; $route.params.username &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 声明式导航 - 传值// 方式1:// to=&quot;/path?参数名=值&quot;// 接收: $route.query.参数名// 方式2:// (1): 路由规则path上 定义 /path/:参数名// (2): to=&quot;/path/值&quot;// 接收: $route.params.参数名export default &#123;&#125;;&lt;/script&gt;\n导航跳转, 传值给Part.vue组件\nApp.vue\n&lt;router-link to=&quot;/part?name=张三&quot;&gt;朋友-张三&lt;/router-link&gt;&lt;router-link to=&quot;/part/李四&quot;&gt;朋友-李四&lt;/router-link&gt;\n\n\n总结: \n\n?key=value   用$route.query.key 取值\n\n/值   提前在路由规则/path/:key  用$route.params.key  取值 (可读性很差，建议不要使用)\n\n\n\n声明导航 - 类名区别\n目标: router-link自带的2个类名的区别是什么\n\n观察路由嵌套导航的样式\n\nrouter-link-exact-active  (精确匹配) url中hash值路径, 与href属性值完全相同, 设置此类名\n\nrouter-link-active             (模糊匹配) url中hash值,    包含href属性值这个路径\n\n\n\n路由重定向和模式修改重定向场景：首次进入页面时，没有任何路由的hash值，页面元素会显示空白，如何解决？\n\n目标: 匹配path后, 强制切换到目标path上\n\n\n网页打开url默认hash值是/路径\nredirect是设置要重定向到哪个路由路径\n\nconst routes = [  &#123;    path: &quot;/&quot;, // 默认hash值路径    redirect: &quot;/find&quot; // 重定向到/find    // 浏览器url中#后的路径被改变成/find-重新匹配数组规则  &#125;]\n\n\n总结: 强制重定向后, 还会重新来数组里匹配一次规则\n\n实际作用：\n\n当某个路由在使用过程中废弃掉之后，将原来路由地址重定向到其他地址\n当满足某个条件时（如：登录信息过期），可以重定向到某个指定位置\n\n路由 - 404页面\n目标: 如果路由hash值, 没有和数组里规则匹配\n\n默认给一个404页面\n\n语法: 路由最后, path匹配*(任意路径) – 前面不匹配就命中最后这个, 显示对应组件页面\n步骤：\n\n创建NotFound页面\n&lt;template&gt;  &lt;img src=&quot;../assets/404.png&quot; alt=&quot;&quot;&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;    img&#123;        width: 100%;    &#125;&lt;/style&gt;\n在main.js - 修改路由配置\nimport NotFound from &#x27;@/views/NotFound&#x27;const routes = [  // ...省略了其他配置  // 404在最后(规则是从前往后逐个比较path)  &#123;    path: &quot;*&quot;,    component: NotFound  &#125;]\n\n\n总结: 如果路由未命中任何规则, 给出一个兜底的404页面\n\n路由模式修改\n目标: 修改路由在地址栏的模式\n\nhash路由例如:  http://localhost:8080/#/home\nhistory路由例如: http://localhost:8080/home  (以后上线需要服务器端支持, 否则找的是文件夹)\nconst router = new VueRouter(&#123;  routes,  mode: &quot;history&quot; // 打包上线后需要后台支持, 模式是hash&#125;)\n\n\n唯一区别，是路由后缀有无#号\n\n编程式导航基础用法语法：\npath和name二选一！\nthis.$router.push(&#123;    path: &quot;路由路径&quot;, // 都去 router/index.js定义    name: &quot;路由名&quot;&#125;)\n\n\nmain.js - 路由数组里, 给路由起名字\n代码规范：一般情况下，path除去/以外的部分和name需要保持一致\n&#123;    path: &quot;/find&quot;,    name: &quot;Find&quot;,    component: Find&#125;,&#123;    path: &quot;/my&quot;,    name: &quot;My&quot;,    component: My&#125;,&#123;    path: &quot;/part&quot;,    name: &quot;Part&quot;,    component: Part&#125;,\nApp.vue - 换成span 配合js的编程式导航跳转\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;span @click=&quot;btn(&#x27;/find&#x27;, &#x27;Find&#x27;)&quot;&gt;发现音乐&lt;/span&gt;      &lt;span @click=&quot;btn(&#x27;/my&#x27;, &#x27;My&#x27;)&quot;&gt;我的音乐&lt;/span&gt;      &lt;span @click=&quot;btn(&#x27;/part&#x27;, &#x27;Part&#x27;)&quot;&gt;朋友&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 编程式导航 - js方式跳转路由// 语法:// this.$router.push(&#123;path: &quot;路由路径&quot;&#125;)// this.$router.push(&#123;name: &quot;路由名&quot;&#125;)// 注意:// 虽然用name跳转, 但是url的hash值还是切换path路径值// 场景:// 方便修改: name路由名(在页面上看不见随便定义)// path可以在url的hash值看到(尽量符合组内规范)export default &#123;  methods: &#123;    btn(targetPath, targetName)&#123;      // 方式1: path跳转      this.$router.push(&#123;        // path: targetPath,        name: targetName      &#125;)    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.footer_wrap &#123;  position: fixed;  left: 0;  top: 0;  display: flex;  width: 100%;  text-align: center;  background-color: #333;  color: #ccc;&#125;.footer_wrap span &#123;  flex: 1;  text-decoration: none;  padding: 20px 0;  line-height: 20px;  background-color: #333;  color: #ccc;  border: 1px solid black;&#125;.footer_wrap span:hover &#123;  background-color: #555;&#125;.top &#123;  padding-top: 62px;&#125;/*激活时样式 */.footer_wrap .router-link-active&#123;  color: white;  background: black;&#125;&lt;/style&gt;\n\n跳转传参\n目标: JS跳转路由, 传参\n\n语法 query / params 任选 一个\nthis.$router.push(&#123;    path: &quot;路由路径&quot;    name: &quot;路由名&quot;,    query: &#123;    \t&quot;参数名&quot;: 值    &#125;    params: &#123;\t\t&quot;参数名&quot;: 值    &#125;&#125;)// 方式1:// params =&gt; $route.params.参数名// 方式2:// query =&gt; $route.query.参数名\n\n格外注意: 使用path的话，只能和query一起使用，不可以使用params(会自动忽略)\nApp.vue\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;span @click=&quot;btn(&#x27;/find&#x27;, &#x27;Find&#x27;)&quot;&gt;发现音乐&lt;/span&gt;      &lt;span @click=&quot;btn(&#x27;/my&#x27;, &#x27;My&#x27;)&quot;&gt;我的音乐&lt;/span&gt;      &lt;span @click=&quot;oneBtn&quot;&gt;朋友-张三&lt;/span&gt;      &lt;span @click=&quot;twoBtn&quot;&gt;朋友-李四&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 编程式导航 - 跳转路由传参// 方式1:// params =&gt; $route.params.参数名// 方式2:// query =&gt; $route.query.参数名// 重要: path会自动忽略params// 注意: 如果当前url上&quot;hash值和?参数&quot;与你要跳转到的&quot;hash值和?参数&quot;一致, //      爆出冗余导航的问题, 不会跳转路由export default &#123;  methods: &#123;    btn(targetPath, targetName)&#123;      // 方式1: path跳转      this.$router.push(&#123;        path: targetPath,        params: &#123;          username: &#x27;东东&#x27;        &#125;      &#125;)    &#125;,    oneBtn()&#123;      this.$router.push(&#123;        // 方式2：name跳转        name: &#x27;Part&#x27;,        params: &#123;          username: &#x27;张三&#x27;        &#125;      &#125;)    &#125;,    twoBtn()&#123;      this.$router.push(&#123;        name: &#x27;Part&#x27;,        query: &#123;          name: &#x27;李四&#x27;        &#125;      &#125;)    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.footer_wrap &#123;  position: fixed;  left: 0;  top: 0;  display: flex;  width: 100%;  text-align: center;  background-color: #333;  color: #ccc;&#125;.footer_wrap span &#123;  flex: 1;  text-decoration: none;  padding: 20px 0;  line-height: 20px;  background-color: #333;  color: #ccc;  border: 1px solid black;&#125;.footer_wrap span:hover &#123;  background-color: #555;&#125;.top &#123;  padding-top: 62px;&#125;/*激活时样式 */.footer_wrap .router-link-active&#123;  color: white;  background: black;&#125;&lt;/style&gt;\n\n路由嵌套\n目标: 在现有的一级路由下, 再嵌套二级路由\n\n二级路由示例-网易云音乐-发现音乐下\n\nrouter-view嵌套架构图\n\n创建所有组件\n\n\nmain.js– 继续配置2级路由\n一级路由path从/开始定义\n二级路由往后path直接写名字, 无需/开头\n嵌套路由在上级路由的children数组里编写路由信息对象\nimport Find from &#x27;./views/Find.vue&#x27; // @是src的绝对地址import My from &#x27;./views/My.vue&#x27;import Part from &#x27;./views/Part.vue&#x27;import NotFound from &#x27;./views/NotFound.vue&#x27;import Recommend from &#x27;./views/Second/Recommend.vue&#x27;import Ranking from &#x27;./views/Second/Ranking.vue&#x27;import SongList from &#x27;./views/Second/SongList.vue&#x27;const routes = [  &#123;    path: &quot;/&quot;, // 默认hash值路径    redirect: &quot;/find&quot; // 重定向到/find    // 浏览器url中#后的路径被改变成/find-重新匹配规则  &#125;,  &#123;    path: &quot;/find&quot;,    name: &quot;Find&quot;,    component: Find,    children: [      &#123;        path: &quot;recommend&quot;,        component: Recommend      &#125;,      &#123;        path: &quot;ranking&quot;,        component: Ranking      &#125;,      &#123;        path: &quot;songlist&quot;,        component: SongList      &#125;    ]  &#125;]\n配置router-view\n\nApp.vue的router-view负责发现音乐和我的音乐页面, 切换\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;footer_wrap&quot;&gt;      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\nFind.vue的的router-view负责发现音乐下的, 三个页面, 切换\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;推荐&lt;/p&gt;    &lt;p&gt;排行榜&lt;/p&gt;    &lt;p&gt;歌单&lt;/p&gt;    &lt;div class=&quot;nav_main&quot;&gt;      &lt;router-link to=&quot;/find/recommend&quot;&gt;推荐&lt;/router-link&gt;      &lt;router-link to=&quot;/find/ranking&quot;&gt;排行榜&lt;/router-link&gt;      &lt;router-link to=&quot;/find/songlist&quot;&gt;歌单&lt;/router-link&gt;    &lt;/div&gt;    &lt;div style=&quot;1px solid red;&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n运行 - 点击导航观察嵌套路由在哪里展示\n\n\n\n总结: \n\n嵌套路由, 找准在哪个页面里写router-view和对应规则里写children\n页面跳转时，多级路由需要把每个阶段的路由地址拼接起来，如: /find/songlist\n写非一级路由时，path里的内容不能有/\n\n\n全局前置守卫beforeEach\n目的: 路由跳转之前, 先执行一次前置守卫函数, 判断是否可以正常跳转\n\n场景：在跳转路由前, 判断用户登陆了才能去&lt;我的音乐&gt;页面, 未登录弹窗提示回到发现音乐页面\n\n在路由对象上使用固定方法beforeEach\n// 目标: 路由守卫// 场景: 当你要对路由权限判断时// 语法: router.beforeEach((to, from, next)=&gt;&#123;//路由跳转&quot;之前&quot;先执行这里, 决定是否跳转&#125;)// 参数1 to: 要跳转到的路由 (路由对象信息)    目标// 参数2 from: 从哪里跳转的路由 (路由对象信息)  来源// 参数3 next: 函数体 - next()才会让路由正常的跳转切换, next(false)在原地停留, next(&quot;强制修改到另一个路由路径上&quot;)// 注意: 如果不调用next, 页面留在原地// 例子: 判断用户是否登录, 是否决定去&quot;我的音乐&quot;/myconst isLogin = true; // 登录状态(未登录)router.beforeEach((to, from, next) =&gt; &#123;  if (to.path === &quot;/my&quot; &amp;&amp; isLogin === false) &#123;    alert(&quot;请登录&quot;)    next(false) // 阻止路由跳转    // next(&#x27;/part&#x27;) // 跳转别的地方  &#125; else &#123;    next() // 正常放行  &#125;&#125;)\n\n\n总结: \n\nnext()放行\nnext(false)留在原地不跳转路由\nnext(path路径)强制换成对应path路径跳转\n\n\n扩展：afterEach\n添加一个导航钩子，在每次导航后执行。返回一个删除注册钩子的函数。\n\n语法：\nrouter.afterEach((to,from)=&gt;&#123;&#125;) \n\n注意：该钩子一般用于跳转到某个页面后，调用某个身份验证接口获取权限\n组件内的独享路由钩子\nbeforeRouteEnter - 在进入到该组件之前，触发\nbeforeRouteUpdate - 仅是当前组件内部的路由发生变化（主路由地址没有改变）时，触发\nbeforeRouteLeave - 离开该组件之前，触发\n\n&lt;script&gt;    export default &#123;        beforeRouteEnter(to, from, next) &#123;            // 在渲染该组件的对应路由被 confirm 前调用            // 不！能！获取组件实例 `this`            // 因为当守卫执行前，组件实例还没被创建            console.log(&#x27;进find&#x27;)            next()        &#125;,        beforeRouteUpdate(to, from, next) &#123;            // 在当前路由改变，但是该组件被复用时调用            // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，            // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。            // 可以访问组件实例 `this`            console.log(&#x27;被复用&#x27;)            next()        &#125;,        beforeRouteLeave(to, from, next) &#123;            // 导航离开该组件的对应路由时调用            // 可以访问组件实例 `this`            console.log(&#x27;离开&#x27;)            next()        &#125;    &#125;;&lt;/script&gt;\n"},{"title":"Vue工具包","url":"/2022/12/02/Vue%E5%B7%A5%E5%85%B7%E5%8C%85/","content":"全选反选&lt;script&gt;computed:&#123;  &#x27;isAll&#x27;:&#123;    get () &#123;    // 数组方法every：查询数组中&#x27;不符合条件&#x27;的元素，如果有一个，立即返回false        return this.list.every(obj =&gt; obj.checked)    &#125;,    set (value) &#123;        // 让所有的小选框变成value        this.list.forEach(obj =&gt; obj.checked = value)    &#125;  &#125;&#125;&lt;/script&gt;\n\n本地存储&lt;script&gt;    watch:&#123;    list:&#123;      handler()&#123;      // 进行本地存储      \tlocalStorage.setItem(&#x27;TASK_LIST&#x27;,JSON.stringify(this.list))\t\t&#125;,\t  deep:true    &#125;&#125;&lt;/script&gt;\n\n路由mian.js:\n// 路由设置的基本配置步骤// 1. (固定)安装路由依赖 npm i vue-router@3.5.1// 2. (固定)在main.js中导入路由import VueRouter from &#x27;vue-router&#x27;// 3. (固定)通过 Vue构造函数 use() 静态方法使用路由Vue.use(VueRouter)// 4. 创建路由规则数组// 4.1 引入页面组件import Find from &#x27;./views/Find.vue&#x27;import My from &#x27;./views/My.vue&#x27;import Part from &#x27;./views/Part.vue&#x27;import NotFound from &quot;./views/NotFound.vue&quot;;import Ranking from &#x27;./views/second/Ranking.vue&#x27;import Recommend from &#x27;./views/second/Recommend.vue&#x27;import SongList from &#x27;./views/second/SongList.vue&#x27;// 4.2 创建规则const routes = [  // 路由对象：在其中建立路由与组件的对应关系  &#123;    path:&#x27;/&#x27;, // 默认根路由    redirect: &#x27;/find&#x27; // 重定向属性，当网页路由为 / 时， 会自动跳转到 /find 路由上  &#125;,  &#123;    path:&#x27;*&#x27;, // * 表示的是，除其他规则外的所有地址    component: NotFound  &#125;,  &#123;    path:&#x27;/find&#x27;, // 路由    component: Find, // 组件    name:&#x27;find&#x27;, // 编程式导航的name    children:[ // 二级路由数组      &#123;        path:&#x27;recommend&#x27;,        component:Recommend      &#125;,      &#123;        path:&#x27;ranking&#x27;,        component:Ranking      &#125;,      &#123;        path:&#x27;songList&#x27;,        component:SongList      &#125;,    ]  &#125;,  &#123;    path:&#x27;/my&#x27;, // 路由    component: My, // 组件    name:&#x27;my&#x27; // 编程式导航的name  &#125;,  &#123;    path:&#x27;/part&#x27;, // 路由    component: Part, // 组件    name:&#x27;part&#x27; // 编程式导航的name  &#125;,  &#123;    path:&#x27;/part/:username&#x27;, // 路由    component: Part // 组件  &#125;,]// 4.5 可以过滤掉路由抛出的错误异常// 编程式导航会遇到一个小问题，当处在A路由上时，想用编程式导航跳转到A路由，会报出错误阻止你重复的跳转const originalPush = VueRouter.prototype.pushVueRouter.prototype.push = function push (location) &#123;  return originalPush.call(this, location).catch(err =&gt; err)&#125;// 5. (固定)创建实例化路由对象 - 传入规则const router = new VueRouter(&#123;  // 解构赋值  routes,    /*     关于路由模式分为2种    1. hash 模式（默认）: 网址中带有 # 号    2. history模式： 网址中不带 # 号    history模式的路由形式 与 接口请求形式是一致的，    后端在不做任何配置的情况下是无法分别究竟是路由跳转还是接口请求，    所以如果以后需要在项目中做history模式的路由跳转时，需要后端同事的支持  */  // mode:&#x27;history&#x27;&#125;)// 3. 实例化vue对象，并且挂载到唯一html页面上new Vue(&#123;  // 6. (固定)将路由关联到vue实例中  router,  render: h =&gt; h(App), // 渲染函数，告诉vue 要渲染那个组件 =&gt; app.vue 根组件&#125;).$mount(&#x27;#app&#x27;) // 确定将这个vue实例挂载到哪里？ =&gt; id为app的盒子中\n"}]