[{"title":"Vue2小笔记","url":"/2022/11/17/vue%E5%B0%8F%E7%AC%94%E8%AE%B0/","content":"Vue小笔记初识Vue：\t1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；\t2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；\t3.root容器里的代码被称为【Vue模板】；\t4.Vue实例和容器是一一对应的；\t5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；\t6.&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；\t7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；\t注意区分：js表达式 和 js代码(语句)\t\t\t1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：\t\t\t\t(1). a\t\t\t\t(2). a+b\t\t\t\t(3). demo(1)\t\t\t\t(4). x === y ? &#x27;a&#x27; : &#x27;b&#x27;\t\t\t2.js代码(语句)\t\t\t\t(1). if()&#123;&#125;\t\t\t\t(2). for()&#123;&#125;\n\nVue模板语法有2大类：\t1.插值语法：\t\t\t功能：用于解析标签体内容。\t\t\t写法：&#123;&#123;xxx&#125;&#125;，xxx是js表达式，且可以直接读取到data中的所有属性。\t2.指令语法：\t\t\t功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。\t\t\t举例：v-bind:href=&quot;xxx&quot; 或  简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式，\t\t\t\t\t 且可以直接读取到data中的所有属性。\t\t\t备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。\n\nVue中有2种数据绑定的方式：\t\t1.单向绑定(v-bind)：数据只能从data流向页面。\t\t2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。\t\t\t备注：\t\t\t\t1.双向绑定一般都应用在表单类元素上（如：input、select等）\t\t\t\t2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。\n\ndata与el的2种写法\t\t1.el有2种写法\t\t\t\t(1).new Vue时候配置el属性。\t\t\t\t(2).先创建Vue实例，随后再通过vm.$mount(&#x27;#root&#x27;)指定el的值。\t\t2.data有2种写法\t\t\t\t(1).对象式\t\t\t\t(2).函数式\t\t\t\t如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。\t\t3.一个重要的原则：\t\t\t\t由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。\n\nMVVM模型\t\t\t1. M：模型(Model) ：data中的数据\t\t\t2. V：视图(View) ：模板代码\t\t\t3. VM：视图模型(ViewModel)：Vue实例观察发现：\t\t\t1.data中所有的属性，最后都出现在了vm身上。\t\t\t2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。\n\nlet number = 18let person = &#123;\tname:&#x27;张三&#x27;,\tsex:&#x27;男&#x27;,&#125;Object.defineProperty(person,&#x27;age&#x27;,&#123;\t// value:18,\t// enumerable:true, //控制属性是否可以枚举，默认值是false\t// writable:true, //控制属性是否可以被修改，默认值是false\t// configurable:true //控制属性是否可以被删除，默认值是false\t//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\tget()&#123;\t\tconsole.log(&#x27;有人读取age属性了&#x27;)\t\treturn number\t&#125;,\t//当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值\tset(value)&#123;\t\tconsole.log(&#x27;有人修改了age属性，且值是&#x27;,value)\t\tnumber = value\t&#125;&#125;)// console.log(Object.keys(person))console.log(person)\n\n&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt;&lt;script type=&quot;text/javascript&quot; &gt;\tlet obj = &#123;x:100&#125;\tlet obj2 = &#123;y:200&#125;\tObject.defineProperty(obj2,&#x27;x&#x27;,&#123;\t\tget()&#123;\t\t\treturn obj.x\t\t&#125;,\t\tset(value)&#123;\t\t\tobj.x = value\t\t&#125;\t&#125;)&lt;/script&gt;\n\n1.Vue中的数据代理：\t\t\t通过vm对象来代理data对象中属性的操作（读/写）2.Vue中数据代理的好处：\t\t\t更加方便的操作data中的数据3.基本原理：\t\t\t通过Object.defineProperty()把data对象中所有属性添加到vm上。\t\t\t为每一个添加到vm上的属性，都指定一个getter/setter。\t\t\t在getter/setter内部去操作（读/写）data中对应的属性。\n\n事件的基本使用：\t\t\t1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；\t\t\t2.事件的回调需要配置在methods对象中，最终会在vm上；\t\t\t3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；\t\t\t4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；\t\t\t5.@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot; 效果一致，但后者可以传参；\n\nVue中的事件修饰符：\t\t1.prevent：阻止默认事件（常用）；\t\t2.stop：阻止事件冒泡（常用）；\t\t3.once：事件只触发一次（常用）；\t\t4.capture：使用事件的捕获模式；\t\t5.self：只有event.target是当前操作的元素时才触发事件；\t\t6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；\n\n1.Vue中常用的按键别名：\t\t\t回车 =&gt; enter\t\t\t删除 =&gt; delete (捕获“删除”和“退格”键)\t\t\t退出 =&gt; esc\t\t\t空格 =&gt; space\t\t\t换行 =&gt; tab (特殊，必须配合keydown去使用)\t\t\t上 =&gt; up\t\t\t下 =&gt; down\t\t\t左 =&gt; left\t\t\t右 =&gt; right2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）3.系统修饰键（用法特殊）：ctrl、alt、shift、meta\t\t\t(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\t\t\t(2).配合keydown使用：正常触发事件。4.也可以使用keyCode去指定具体的按键（不推荐）5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n\n计算属性：\t\t1.定义：要用的属性不存在，要通过已有属性计算得来。\t\t2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。\t\t3.get函数什么时候执行？\t\t\t\t\t(1).初次读取时会执行一次。\t\t\t\t\t(2).当依赖的数据发生改变时会被再次调用。\t\t4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\t\t5.备注：\t\t\t\t1.计算属性最终会出现在vm上，直接读取使用即可。\t\t\t\t2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\n\n监视属性watch：\t1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作\t2.监视的属性必须存在，才能进行监视！！\t3.监视的两种写法：\t\t\t(1).new Vue时传入watch配置\t\t\t(2).通过vm.$watch监视\n\n深度监视：\t\t(1).Vue中的watch默认不监测对象内部值的改变（一层）。\t\t(2).配置deep:true可以监测对象内部值改变（多层）。备注：\t\t(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！\t\t(2).使用watch时根据数据的具体结构，决定是否采用深度监视。\n\ncomputed和watch之间的区别：\t\t1.computed能完成的功能，watch都可以完成。\t\t2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。两个重要的小原则：\t\t\t1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。\t\t\t2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，\t\t\t\t这样this的指向才是vm 或 组件实例对象。\n\n1. class样式\t\t\t写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。\t\t\t\t\t字符串写法适用于：类名不确定，要动态获取。\t\t\t\t\t对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\t\t\t\t\t数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。2. style样式\t\t\t:style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。\t\t\t:style=&quot;[a,b]&quot;其中a、b是样式对象。\n\n1.v-if\t\t\t写法：\t\t\t\t\t(1).v-if=&quot;表达式&quot; \t\t\t\t\t(2).v-else-if=&quot;表达式&quot;\t\t\t\t\t(3).v-else=&quot;表达式&quot;\t\t\t适用于：切换频率较低的场景。\t\t\t特点：不展示的DOM元素直接被移除。\t\t\t注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。2.v-show\t\t\t写法：v-show=&quot;表达式&quot;\t\t\t适用于：切换频率较高的场景。\t\t\t特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\t3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。\n\n面试题：react、vue中的key有什么作用？（key的内部原理）\t\t\t\t1. 虚拟DOM中key的作用：\t\t\t\t\t\tkey是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, \t\t\t\t\t\t随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：\t\t\t\t\t\t\t\t2.对比规则：\t\t\t\t\t(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：\t\t\t\t\t\t\t\t①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！\t\t\t\t\t\t\t\t②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\t\t\t\t\t(2).旧虚拟DOM中未找到与新虚拟DOM相同的key\t\t\t\t\t\t\t\t创建新的真实DOM，随后渲染到到页面。\t\t\t\t\t\t\t\t\t\t3. 用index作为key可能会引发的问题：\t\t\t\t\t\t\t1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:\t\t\t\t\t\t\t\t\t\t\t会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。\t\t\t\t\t\t\t2. 如果结构中还包含输入类的DOM：\t\t\t\t\t\t\t\t\t\t\t会产生错误DOM更新 ==&gt; 界面有问题。\t\t4. 开发中如何选择key?:\t\t\t\t\t\t\t1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。\t\t\t\t\t\t\t2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，\t\t\t\t\t\t\t\t使用index作为key是没有问题的。\n\nVue监视数据的原理：\t1. vue会监视data中所有层次的数据。\t2. 如何监测对象中的数据？\t\t\t\t\t通过setter实现监视，且要在new Vue时就传入要监测的数据。\t\t\t\t\t\t(1).对象中后追加的属性，Vue默认不做响应式处理\t\t\t\t\t\t(2).如需给后添加的属性做响应式，请使用如下API：\t\t\t\t\t\t\t\t\t\tVue.set(target，propertyName/index，value) 或 \t\t\t\t\t\t\t\t\t\tvm.$set(target，propertyName/index，value)\t3. 如何监测数组中的数据？\t\t\t\t\t\t通过包裹数组更新元素的方法实现，本质就是做了两件事：\t\t\t\t\t\t\t(1).调用原生对应的方法对数组进行更新。\t\t\t\t\t\t\t(2).重新解析模板，进而更新页面。\t4.在Vue修改数组中的某个元素一定要用如下方法：\t\t\t\t1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()\t\t\t\t2.Vue.set() 或 vm.$set()\t\t特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！\n\n收集表单数据：\t\t若：&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的就是value值。\t\t若：&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值，且要给标签配置value值。\t\t若：&lt;input type=&quot;checkbox&quot;/&gt;\t\t\t\t1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）\t\t\t\t2.配置input的value属性:\t\t\t\t\t\t(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\t\t\t\t\t\t(2)v-model的初始值是数组，那么收集的的就是value组成的数组\t\t备注：v-model的三个修饰符：\t\t\t\t\t\tlazy：失去焦点再收集数据\t\t\t\t\t\tnumber：输入字符串转为有效的数字\t\t\t\t\t\ttrim：输入首尾空格过滤\n\n过滤器：\t定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。\t语法：\t\t\t1.注册过滤器：Vue.filter(name,callback) 或 new Vue&#123;filters:&#123;&#125;&#125;\t\t\t2.使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125;  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;\t备注：\t\t\t1.过滤器也可以接收额外参数、多个过滤器也可以串联\t\t\t2.并没有改变原本的数据, 是产生新的对应的数据\n\n我们学过的指令：\t\tv-bind\t: 单向绑定解析表达式, 可简写为 :xxx\t\tv-model\t: 双向数据绑定\t\tv-for  \t: 遍历数组/对象/字符串\t\tv-on   \t: 绑定事件监听, 可简写为@\t\tv-if \t \t: 条件渲染（动态控制节点是否存存在）\t\tv-else \t: 条件渲染（动态控制节点是否存存在）\t\tv-show \t: 条件渲染 (动态控制节点是否展示)v-text指令：\t\t1.作用：向其所在的节点中渲染文本内容。\t\t2.与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。v-html指令：\t\t1.作用：向指定节点中渲染包含html结构的内容。\t\t2.与插值语法的区别：\t\t\t\t\t(1).v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会。\t\t\t\t\t(2).v-html可以识别html结构。\t\t3.严重注意：v-html有安全性问题！！！！\t\t\t\t\t(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。\t\t\t\t\t(2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！v-cloak指令（没有值）：\t\t1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。\t\t2.使用css配合v-cloak可以解决网速慢时页面展示出&#123;&#123;xxx&#125;&#125;的问题。v-once指令：\t\t\t1.v-once所在节点在初次动态渲染后，就视为静态内容了。\t\t\t2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。v-pre指令：\t\t1.跳过其所在节点的编译过程。\t\t2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。\n\n需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。自定义指令总结：\t\t一、定义语法：\t\t\t\t\t(1).局部指令：\t\t\t\t\t\t\t\tnew Vue(&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Vue(&#123;\t\t\t\t\t\t\t\t\tdirectives:&#123;指令名:配置对象&#125;   或   \t\tdirectives&#123;指令名:回调函数&#125;\t\t\t\t\t\t\t\t&#125;) \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#125;)\t\t\t\t\t(2).全局指令：\t\t\t\t\t\t\t\t\tVue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)\t\t二、配置对象中常用的3个回调：\t\t\t\t\t(1).bind：指令与元素成功绑定时调用。\t\t\t\t\t(2).inserted：指令所在元素被插入页面时调用。\t\t\t\t\t(3).update：指令所在模板结构被重新解析时调用。\t\t三、备注：\t\t\t\t\t1.指令定义时不加v-，但使用时要加v-；\t\t\t\t\t2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。\n\n一、定义语法：(1).局部指令：\t\tnew Vue(&#123;\tdirectives:&#123;指令名:配置对象&#125;&#125;) \t\t\t\t\t\t\t\t\t\t\t\t\t\t或  new Vue(&#123;directives&#123;指令名:回调函数&#125;&#125;)(2).全局指令：\t\tVue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)二、配置对象中常用的3个回调：\t\t\t\t(1).bind：指令与元素成功绑定时调用。\t\t\t\t(2).inserted：指令所在元素被插入页面时调用。\t\t\t\t(3).update：指令所在模板结构被重新解析时调用。三、备注：\t\t\t\t1.指令定义时不加v-，但使用时要加v-；\t\t\t\t2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。\n\n生命周期：\t\t\t\t\t\t1.又名：生命周期回调函数、生命周期函数、生命周期钩子。\t\t\t\t\t\t2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\t\t\t\t\t\t3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\t\t\t\t\t\t4.生命周期函数中的this指向是vm 或 组件实例对象。\n\n"}]