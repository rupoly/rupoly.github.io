[{"title":"Vue笔记","url":"/2022/11/22/Vue%E7%AC%94%E8%AE%B0/","content":"接近Vue入口文件的特点​    要想要某个页面或文件在项目中生效，一定会直接或间接的与入口文件产生联系\n\n引入vue依赖 =&gt; 如果引入的是第三方依赖，那么路径不必写成相对或绝对路径import Vue from &#x27;vue&#x27;\n引入根组件import App from &#x27;./APP.vue&#x27;\n\nvue项目的一个控制台打印提示，默认关闭Vue.config.productionTip = false\n\n\n实例化vue对象，并且挂载到唯一html页面上new Vue(&#123;  render: h =&gt; h(App), // 渲染函数，告诉vue要渲染的组件&#125;).$mount(&#x27;#app&#x27;) // 确定vue实例挂载的盒子\n\n\n自定义vue中开发服务器配置及关闭eslint检查自定义服务器配置在vue.config.js文件中，moudule.exports添加devServer:&#123;  // 自定义开发服务器配置    prot: 3000 // 自定义端口号&#125;\n全局关闭eslint检查lintOnSave:false // \n局部关闭eslint检查​    直接添加//注释即可\n// 只能忽略下一行代码的eslint检测：// eslint-disable-next-linelet a = 10// 只能忽略当前行代码的eslint检测：let b = 20// eslint-disable-line// 忽略后续代码的eslint检测：/* eslint-disable *//* eslint-disable */let c = 30 let d = 40let e = 50// 开启后续代码的eslint检测：/* eslint-enable *//* eslint-enable */let f = 60\n\n关于.vue文件中的三个标签\ntemplate标签标签模板 =&gt; 对应记忆对照html文件中的&lt;html&gt;标签结构vue模板标签中，只能有一个根标签!\nscript标签// js相关的代码// 在js中 有一个 export default &#123;&#125; 结构， 在这个结构中需要遵循vue的代码规则\nstyle标签/* 当前组件样式表 - 期望每个组件中的style 标签只能影响当前组件中的标签内容 *//* 只需要在style 标签中添加一个属性 - scoped 就可以让样式只作用于当前组件的标签 *//* 原理: scoped 属性，会为每一个样式表自动添加当前组件中所被设置的自定义属性（data-v-hash随机数），形成一个复合选择器，而能够被选中的标签均存在于当前组件中，所以可以被区分开 *//* 规律/要求: 只要组件需要设置style样式，就在style标签中添加 scoped 属性 */\n\nMVVM模型的理解​    设计模式: 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。\n\nMVVM，一种软件架构模式，决定了写代码的思想和层次\nM：   model数据模型          (data里定义)    \nV：    view视图                   （html页面）\nVM： ViewModel视图模型  (vue.js源码)\n\n\n\n\nMVVM通过数据双向绑定让数据自动地双向同步  不再需要操作DOM\nV（修改视图） -&gt; M（数据自动同步）\nM（修改数据） -&gt; V（视图自动同步）\n\n\n\n\n总结：\n​        vue使用的mvvm设计模式。MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。\n在MVVM模型之前使用的MVC模型：\n\n​        MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。\n原生的HTML + JS就是使用的这个模型\n\n将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。\n\n\n\n\n\n\n关于Vue中的属性V-bind动态属性详解语法： v-bind:属性名=”vue中定义的变量/表达式”\n简化的语法： 将v-bind:属性名 转化为 =&gt; :属性名\n&lt;a v-bind:href=&quot;baiduUrl&quot;&gt;&#123;&#123; url &#125;&#125;&lt;/a&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            baiduUrl:&#x27;http://www.baidu.com&#x27;,            url:&#x27;www.baidu.com&#x27;,        &#125;    &#125;&#125;\n\n注意点：\n关于v-bind动态属性作用于图片时尤其需要注意：v-bind 会直接把资源路径认定为字符串\n解决方式：直接在v-bind动态属性后面传递实际的资源\n方法1：通过import引入资源文件，在data中进行定义，最后在动态属性中使用\n&lt;img v-bind:src=&quot;img1&quot; alt=&quot;&quot;&gt;\n\n// 引入importimport img from &#x27;../assets/logo.png&#x27;export default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 在data中设置路径，引入            img1:img,        &#125;    &#125;&#125;\n\n方法2：通过require 引入资源文件，直接在动态属性中使用\n&lt;img v-bind:src=&quot;img2&quot; alt=&quot;&quot;&gt;\n\nexport default &#123;    name:&#x27;DemoIndex2&#x27;,    data()&#123;        return&#123;            // 通过require 引入资源文件，直接在动态属性中使用            img2:require(&#x27;../assets/logo.png&#x27;)        &#125;    &#125;&#125;\n\n开发中一般会使用方法2，优势： require引入资源的方式是按需的，这样一来，页面初始更新效率会更高\nv-on事件绑定语法：\nv-on:事件名=&quot;简单的函数执行体&quot; =&gt; 只有一行代码v-on:事件名=&quot;methods中定义的方法&quot;v-on:事件名=&quot;methods中定义的方法(实际参数)&quot;简写: v-on: =&gt; @     @事件名=&quot;methods中定义的方法&quot;\n\n使用：\n&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count++&quot;&gt;点我加1&lt;/button&gt;&lt;button v-on:click=&quot;addCount2&quot;&gt;点我加2并打印&lt;/button&gt;&lt;button @click=&quot;addCountN(7)&quot;&gt;点我加7&lt;/button&gt;\n\nexport default &#123;  name: &quot;DemoIndex03&quot;,  data() &#123;    return &#123;      count: 0,    &#125;;  &#125;,  // vue组件的方法定义在methods对象中  methods: &#123;    // 点击加2并打印    addCount2() &#123;      this.count += 2;      console.log(this.count);    &#125;,    // 点击加按钮传递过来的数字    addCountN(num) &#123;      this.count += num;    &#125;,  &#125;,&#125;;\n\nv-on获取事件对象\nvue事件处理函数中, 拿到事件对象\n\n语法:\n\n无传参, 通过形参直接接收\n传参, 通过$event指代事件对象传给事件处理函数\n\n&lt;template&gt;&lt;div&gt;    &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;hr /&gt;    &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/a&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            // 1. 事件触发, 无传值, 可以直接获取事件对象是            one(e)&#123;                console.log(e)                e.preventDefault()            &#125;,            // 2. 事件触发, 传值, 需要手动传入$event            two(num, e)&#123;                console.log(e)                e.preventDefault()            &#125;        &#125;    &#125;;&lt;/script&gt;\n\n如何不用e这个事件对象而阻止默认行为呢？↓  事件修饰符\nv-on修饰符语法:\n\n@事件名.修饰符=”methods里函数”\n.stop - 阻止事件冒泡\n.prevent - 阻止默认行为\n.once - 程序运行期间, 只触发一次事件处理函数\n\n\n\n&lt;template&gt;&lt;div&gt;    &lt;div @click=&quot;fatherFn&quot;&gt;        &lt;p @click.stop=&quot;oneFn&quot;&gt;.stop - 阻止事件冒泡&lt;/p&gt;        &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.stop&gt;去百度&lt;/a&gt;        &lt;p @click.once=&quot;twoFn&quot;&gt;点击观察事件处理函数执行几次&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            fatherFn()&#123;                console.log(&quot;fahter-触发click事件&quot;);            &#125;,            oneFn()&#123;                console.log(&quot;p标签点击了&quot;);            &#125;,            twoFn()&#123;                console.log(&quot;p标签被点击了&quot;);            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-on按键修饰符\n给键盘事件, 添加修饰符\n\n语法:\n\n@keyup.enter  -  监测回车按键\n@keyup.esc     -   监测返回按键\n更多修饰符\n\n&lt;template&gt;&lt;div&gt;    &lt;!-- 1. 绑定键盘按下事件.enter-回车 --&gt;    &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt;    &lt;!-- 2. .esc修饰符 - 取消键 --&gt;    &lt;hr&gt;    &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            enterFn()&#123;                console.log(&quot;用户按下的回车&quot;);            &#125;,            escFn()&#123;                console.log(&quot;用户按下esc键&quot;);            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-model\n把value属性和vue数据变量, 双向绑定到一起\n\n基础用法\n语法: v-model=”vue数据变量”\n双向数据绑定\n数据变化 -&gt; 视图自动同步\n视图变化 -&gt; 数据自动同步\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--         v-model 这个指令可以实现表单控件中数据与视图的双向绑定        1. 数据改变 =&gt; 视图自动同步        2. 视图改变 =&gt; 数据自动同步     --&gt;    &lt;!-- 1. input type=&#x27;test&#x27; 将 value 属性替换成 v-model --&gt;    &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;    &lt;!-- 2. 下拉选择框 select 将name属性替换成 v-model --&gt;    &lt;select v-model=&quot;city&quot;&gt;        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;    &lt;!-- 3. 单选框 将 name 属性替换成 v-model --&gt;    &lt;input type=&quot;radio&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt; 男    &lt;input type=&quot;radio&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt; 女    &lt;!-- 4. 复选框        将 name 属性替换成 v-model =&gt; v-model中绑定一个数组\t\t选中项就是数组中的每一个元素        将 name 属性替换成 v-model =&gt; v-model中绑定的是一个非数组\t\t当切换选择状态时会以布尔值的形式来做状态的切换    --&gt;    &lt;input type=&quot;checkbox&quot; value=&quot;唱&quot; v-model=&quot;hobby&quot;&gt; 唱    &lt;input type=&quot;checkbox&quot; value=&quot;跳&quot; v-model=&quot;hobby&quot;&gt; 跳    &lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; v-model=&quot;hobby&quot;&gt; rap    &lt;input type=&quot;checkbox&quot; value=&quot;唱&quot; v-model=&quot;hobby1&quot;&gt; 唱    &lt;input type=&quot;checkbox&quot; value=&quot;跳&quot; v-model=&quot;hobby2&quot;&gt; 跳    &lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; v-model=&quot;hobby3&quot;&gt; rap    &lt;!-- 5. 文本域  将双标签中的内容 替换为 标签内的 v-model指令 --&gt;    &lt;textarea v-model=&quot;textarea&quot;&gt;&lt;/textarea&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex05&#x27;,    data () &#123;        return &#123;            inputValue:&#x27;123&#x27;,            city:&#x27;&#x27;,            sex:&#x27;&#x27;,            hobby:[],            hobby1:&#x27;&#x27;,            hobby2:false,            hobby3:0,            textarea:&#x27;333&#x27;        &#125;    &#125;,&#125;&lt;/script&gt;\n\n原理：当一个Vue实现创建时，Vue会遍历data选项的属性，用Object.defineProperty将它们转化为getter/setter并且在内部追踪相关依赖，在属性被访问拒绝和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。\nv-model 的修饰符语法: v-model.修饰符=&quot;vue数据变量&quot;\n\n.number               以parseFloat转成数字类型（会自动清除非数字及以后部分）\n.trim （常用）  去除首尾空白字符\n.lazy                   在change时触发而非input时（一切可以触发change事件的情况，如失焦）\n\n&lt;template&gt;  &lt;div&gt;     &lt;span&gt;转化为数字&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.number=&quot;newNumber&quot;&gt;     &lt;hr&gt;     &lt;span&gt;取消前后空格&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.trim=&quot;newTrim&quot;&gt;     &lt;hr&gt;     &lt;span&gt;懒更新&lt;/span&gt;     &lt;input type=&quot;text&quot; v-model.lazy=&quot;newLazy&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex&#x27;,    data () &#123;        return &#123;            newNumber:&#x27;&#x27;,            newTrim:&#x27;&#x27;,            newLazy:&#x27;&#x27;        &#125;    &#125;&#125;&lt;/script&gt;\n\nv-text和v-html\n作用: 更新DOM对象的innerText/innerHTML\n注意： v-text或v-html会覆盖标签内的所有子元素\n\n语法:\n\nv-text=”vue数据变量”    \nv-html=”vue数据变量” \n\n&lt;template&gt;  &lt;div&gt;    &lt;!--       v-text =&gt; 代替了webapi中的 innerText      v-html =&gt; 代替了webapi中的 innerHTML      v-text 使用时不允许当前标签内有任何子元素      原因: 本来当前元素中的内容就会被v-text中的内容覆盖，\t      所以当前标签中的子元素显得毫无意义甚至影响页面的渲染效率    --&gt;    &lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt;    &lt;p v-html=&quot;text&quot;&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name:&#x27;DemoIndex07&#x27;,  data () &#123;    return &#123;      text:&#x27;&lt;span style=&quot;color: red;&quot;&gt;这是一个字符串&lt;/span&gt;&#x27;    &#125;  &#125;,&#125;&lt;/script&gt;\n\nv-show和v-if\nv-show控制标签的显示和隐藏，v-if控制标签在dom中是否存在\n\n\n语法:\nv-show=”vue变量”            \nv-if=”vue变量” \n\n\n原理\nv-show 用的display:none隐藏   (频繁切换使用)\nv-if  直接从DOM树上移除\n\n\n高级\nv-else使用\n\n\n使用场景及区别\nv-show 一般用于单个没有子元素或者子元素都是静态元素的标签\nv-if 常用于弹窗表单\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--     通过变量的boolean值隐式转化，来判断是true或者是false\t为true时显示，为false时隐藏    =&gt;     1. 变量是否必须是布尔值？\t   =&gt; 不必须是布尔值，只需要查看它的隐式转化结果       隐式转化为false的情况: 0 / &#x27;&#x27; / null / undefined / NaN     v-show=&quot;变量&quot;    原理: 给当前标签设置一个display: none; \t来进行隐藏操作，原来的这个标签元素还存在于dom数中    v-if=&quot;变量&quot;    原理: 直接将需要隐藏的元素从dom树中删除    还可以和 v-else-if 和 v-else进行连用，\t它的判断逻辑与 js中 if else 完全相同    当使用v-if/v-else-if/v-else 时\t他们之间必须是连续的兄弟标签    *** 选择v-show和v-if的直接条件: \t如果当前元素及内部子元素全是静态数据，那么使用v-show\t除此以外全用v-if    --&gt;    &lt;div v-show=&quot;flag&quot;&gt;v-show&lt;/div&gt;    &lt;div v-if=&quot;flag&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;div v-if=&quot;flag1 === 0&quot;&gt;显示为0&lt;/div&gt;    &lt;div v-else-if=&quot;flag1 === 1&quot;&gt;显示为1&lt;/div&gt;    &lt;div v-else&gt;显示为其他&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;DemoIndex08&quot;,  data() &#123;    return &#123;      flag: true,      msg: &quot;动态&quot;,      flag1: 0,    &#125;;  &#125;,&#125;;&lt;/script&gt;\n\nv-for循环\n渲染列表数据时，直接在标签结构中进行数组遍历\n循环时需要给v-for当前标签加上一个key属性，用来表现每个被循环出来的标签结构唯一且不同\n\n\n语法 （类比forEach）\n\nv-for=”(值, 索引) in 目标结构”\nv-for=”值 in 目标结构”\n\n\n目标结构:\n\n可以遍历数组 / 对象 / 数字 / 字符串 (可遍历结构)\n\n\n注意:\nv-for的临时变量名不能用到v-for范围外\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;!--         v-for 数据循环指令        语法:        与forEach的使用方式进行联合记忆\t\t它的每次循环得到的数据和索引的用法与forEach完全一样        1. v-for=&quot;(value, index) in 目标数据结构&quot;        2. v-for=&quot;value in 目标数据结构&quot;        在v-for循环体中\t\t必须为每一个循环标签加上一个key属性来表示当前标签的唯一性        forEach((value, index) =&gt; &#123;&#125;)        forEach(value =&gt; &#123;&#125;)    --&gt;    &lt;!-- 1. 循环简单数组 √ --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in arr&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 2. 循环复杂数组 =&gt; 数组对象 √ --&gt;    &lt;div&gt;        &lt;p v-for=&quot;value in arr2&quot; :key=&quot;value.id&quot;&gt;            &#123;&#123; value.name &#125;&#125; ----- &#123;&#123; value.age &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 3. 循环对象 =&gt; 循环的就是对象的属性名和属性值 √ --&gt;    &lt;!-- 参数1： 属性值    参数2： 属性名 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, key) in obj&quot; :key=&quot;key&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; key &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 4. 循环数字 --&gt;    &lt;!-- 参数1： 从1开始计数到最后的自然数  参数2： 下标索引从0开始计数 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in 10&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 5. 循环字符串 --&gt;    &lt;!-- 参数1： 字符串的每一个字符  参数2： 字符所在的下标索引，从0开始计数 --&gt;    &lt;div&gt;        &lt;p v-for=&quot;(value, index) in &#x27;abcdefg&#x27;&quot; :key=&quot;index&quot;&gt;            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;    \t&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;DemoIndex10&#x27;,    data() &#123;        return &#123;            arr:[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;],            arr2:[                &#123; name:&#x27;cxk&#x27;, age:24, id:1&#125;,                &#123; name:&#x27;lbw&#x27;, age:30, id:2&#125;            ],            obj:&#123;                name:&#x27;cxk&#x27;,                age:111,                sex:&#x27;不详&#x27;            &#125;,            arr3:[1, 2, 3, 4, 5, 6]        &#125;    &#125;,&#125;;&lt;/script&gt;\n\n注意：  避免v-for和v-if同时使用\n​        当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度\n解决方法：在v-for前对数组进行筛选\n&lt;!--     v-for 会比 v-if 有更高的优先级，那么数据渲染出来以后才会进行v-if判断，一增一删毫无意义，所以不希望在同一个标签中使用v-if    解决方案： 直接把v-if中的逻辑判断放到filter的函数执行体中即可--&gt;&lt;p v-for=&quot;(value, index) in arr3.filter(value =&gt; value &gt;= 3)&quot; :key=&quot;index&quot;&gt;    &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;&lt;/p&gt;\n\nv-for更新监测\n原因: 当v-for遍历的目标结构改变, Vue触发v-for的更新\n\n&lt;div&gt;  &lt;div v-for=&quot;(value, index) in arr1&quot; :key=&quot;index&quot;&gt;    &#123;&#123; value &#125;&#125;  &lt;/div&gt;  &lt;hr /&gt;  &lt;!-- 数组的翻转 --&gt;  &lt;button @click=&quot;reverseBtn&quot;&gt;点击翻转数组&lt;/button&gt;  &lt;!-- 截取数组的前3个 --&gt;  &lt;button @click=&quot;sliceBtn&quot;&gt;点击截取数组&lt;/button&gt;  &lt;!-- 将第一个元素改成1000 --&gt;  &lt;button @click=&quot;changeFirstBtn&quot;&gt;点击修改第一个元素&lt;/button&gt;&lt;/div&gt;\n\nexport default &#123;  name: &quot;DemoIndex01&quot;,  data() &#123;    return &#123;      arr1: [5, 3, 2, 1, 9],    &#125;;  &#125;,  methods: &#123;    // 翻转数组的方法    reverseBtn() &#123;      this.arr1.reverse();    &#125;,    // 截取数组的前三位    sliceBtn() &#123;      // 发现使用slice进行数组截取，页面上不会发生变化      // 其原因是slice不会改变原数组，所以需要重新赋值      // this.arr1 = this.arr1.slice(0, 3)      // 标准修改方法 ↓      this.arr1.splice(3, 2);    &#125;,    // 修改第一个元素    changeFirstBtn() &#123;      // 这种直接通过索引改变数组某个元素的方式不是标准修改形式      // 通过length进行数组元素的增加和删除的方式也不是标准修改形式      this.arr1[0] = 1000;      // 发现通过索引到的方式无法让页面监听到数组元素的改变      // 通过 vue 提供的内置方法来强制刷新 =&gt; this.$set      // this.$set(更新的目标结构, 更新的位置, 更新的数据)      // 如果某个修改数据的方法需要用到this.$set才可以实现数据监听时，      // 那么这个方法一定不是一个标准化的规范修改过程，一定有与之替换的标准化解决方案，      // 所以去用标准方案吧      this.$set(this.arr1, 0, 1000);      // splice 是修改数组中某个元素的标准化解决方案      // this.arr1.splice(0, 1, 1000)    &#125;,  &#125;,&#125;;\n\n\n数组变更方法, 就会导致v-for更新, 页面更新\n\n数组非变更方法, 返回新数组, 就不会导致v-for更新, 可采用覆盖数组或this.$set()\n\n\nv-for 立即更新\nv-for 的默认行为会尝试原地修改元素而不是移动它们。\n简单来说就是不删除原来的dom元素，而是尽量去修改各循环元素内部的值\n\n\n&lt;div&gt;    &lt;ul&gt;        &lt;li v-for=&quot;(val, ind) in arr&quot; :key=&quot;ind&quot;&gt;            &#123;&#123; val &#125;&#125;        &lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;btn&quot;&gt;下标1位置插入新来的&lt;/button&gt;&lt;/div&gt;\n\nexport default &#123;    data()&#123;        return &#123;            arr: [&#x27;老大&#x27;, &quot;老二&quot;, &#x27;老三&#x27;]        &#125;    &#125;,    methods: &#123;        btn()&#123;            // 索引为1的位置插入一个元素            this.arr.splice(1, 0, &#x27;新来的&#x27;)        &#125;    &#125;&#125;\n\nVue 过滤器filter定义使用\n目的: 转换格式, 过滤器就是一个函数, 传入值返回处理后的值\n简单理解就是在数据渲染到页面之前的过程中，进行一次包装处理\n\n注意：过滤器只能用在, 插值表达式和v-bind表达式\nVue中的过滤器场景：\n\n字母转大写, 输入”hello”, 输出”HELLO”\n字符串翻转, “输入hello, world”, 输出”dlrow ,olleh”\n\n语法: \n\nVue.filter(“过滤器名”, (值) =&gt; {return “返回处理后的值”})\nfilters: {过滤器名字: (值) =&gt; {return “返回处理后的值”}\n\n注意：一定要有返回值\n例子:\n\n全局定义字母都大写的过滤器\n局部定义字符串翻转的过滤器\n\n&lt;div&gt;    &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;!-- 2. 过滤器使用    语法: &#123;&#123; 值 | 过滤器名字 &#125;&#125;    --&gt;    &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; msg | toUp &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      msg: &#x27;Hello, Vue&#x27;    &#125;  &#125;,  // 方式2: 局部 - 过滤器  // 只能在当前vue文件内使用  /*     语法:      filters: &#123;       过滤器名字 (val) &#123;         return 处理后的值       &#125;     &#125;  */  filters: &#123;    toUp (val) &#123;      return val.toUpperCase()    &#125;  &#125;&#125;\n\nmain.js\n// 过滤器接参数Vue.filter(&quot;reverse&quot;, (val, s) =&gt; &#123;    return val.split(&quot;&quot;).reverse().join(s || &#x27;&#x27;)&#125;)\n\n传参和多过滤器\n可同时使用多个过滤器, 或者给过滤器传参\n从左往右依次过滤\n\n语法:\n\n过滤器传参:   vue变量 | 过滤器(实参) \n多个过滤器:   vue变量 | 过滤器1 | 过滤器2\n\n&lt;div&gt;    &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;!-- 1.      给过滤器传值      语法: vue变量 | 过滤器名(值)     --&gt;    &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse(&#x27;|&#x27;) &#125;&#125;&lt;/p&gt;    &lt;!-- 2.      多个过滤利使用      语法: vue变量 | 过滤器1 | 过滤器2     --&gt;    &lt;p&gt;&#123;&#123; msg | toUp | reverse(&#x27;|&#x27;) &#125;&#125;&lt;/p&gt;  &lt;/div&gt;\n\nVue 计算属性computed\n场景： 页面上某一个变量是由其他两个或多个变量通过一定的逻辑运算后得到的时候，可以用到计算属性进行简化\n\n基础语法语法:\ncomputed: &#123;    &quot;计算属性名&quot; () &#123;        return &quot;值&quot;    &#125;&#125;\n\n需求：求2个数的和显示到页面上\n&lt;div&gt;    &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      a: 10,      b: 20    &#125;  &#125;,  // 计算属性:  // 场景: 一个变量的值, 需要用另外变量计算而得来  /*    语法:    computed: &#123;      计算属性名 () &#123;        return 值      &#125;    &#125;  */ // 注意: 计算属性和data属性都是变量-不能重名 // 注意2: 函数内变量变化, 会自动重新计算结果返回  computed: &#123;    num()&#123;      return this.a + this.b    &#125;  &#125;&#125;\n\n总结：\n\n使用场景： 当变量的值, 需要通过别人计算而得来\n特点：函数内使用的变量改变, 重新计算结果返回\n注意事项：计算属性名和data里名字不能重复\n\ncomputed缓存\n目标: 计算属性是基于它们的依赖项的值结果进行缓存的，只要依赖的变量不变, 都直接从缓存取结果\n以上也是计算属性和方法的区别\n\n场景： 通过函数与计算属性做对比\n&lt;div&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; getMessage() &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\n\n\nexport default &#123;  data()&#123;    return &#123;      msg: &quot;Hello, Vue&quot;    &#125;  &#125;,  // 计算属性优势:  // 带缓存  // 计算属性对应函数执行后, 会把return值缓存起来  // 依赖项不变, 多次调用都是从缓存取值  // 依赖项值-变化, 函数会&quot;自动&quot;重新执行-并缓存新的值  computed: &#123;    reverseMessage()&#123;      console.log(&quot;计算属性执行了&quot;);      return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;)    &#125;  &#125;,  methods: &#123;    getMessage()&#123;      console.log(&quot;函数执行了&quot;);      return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;)    &#125;  &#125;&#125;\n\n小结：\n\n计算属性优势：\n带缓存 \n依赖项不变, 直接从缓存取\n依赖项改变, 函数自动执行并重新缓存\n\n\n 因为要消耗内存，所以也是计算属性的缺点\n\ncomputed的完整写法\n计算属性也是变量, 如果想要直接赋值, 需要使用完整写法\n场景： 当计算属性变量作为表单的值时\n注意事项：在实际开发过程中，几乎(99.9%)使用完整写法的计算属性，只有用在全选反选上\n\n语法：\ncomputed: &#123;    &quot;属性名&quot;: &#123;        set(值)&#123;                    &#125;,        get() &#123;            return &quot;值&quot;        &#125;    &#125;&#125;\n\n需求：让计算属性给v-model使用\n&lt;div&gt;    &lt;span&gt;姓名:&lt;/span&gt;    &lt;input type=&quot;text&quot; v-model=&quot;full&quot;&gt;&lt;/div&gt;\n\ncomputed: &#123;    data () &#123;        return &#123;            num1: 10,            num2: 20，            num3: 0        &#125;    &#125;,    full: &#123;        // 给full赋值触发set方法        set(val)&#123;            this.num3 = val        &#125;,        // 使用full的值触发get方法        get()&#123;            return this.num1 + this.num2        &#125;    &#125;&#125;\n\n小结：\n\n当需要给计算属性赋值时，会用到计算属性，但这种情况非常少。\nset函数和get函数的执行时机\nset接收要赋予的值\nget里要返回给这个计算属性具体值\n\n\n\nVue 侦听器watch\n可以侦听data/computed属性值改变\n\n​        一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。\n基本语法语法：\nwatch: &#123;    &quot;被侦听的属性名&quot; (newVal, oldVal)&#123;            &#125;&#125;\n\n例子：\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;obj.name&quot;&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      name: &quot;&quot;,      obj: &#123;        name: &#x27;&#x27;      &#125;    &#125;  &#125;,  // 目标: 侦听到name值的改变  /*  语法:    watch: &#123;      变量名 (newVal, oldVal)&#123;        // 变量名对应值改变这里自动触发      &#125;    &#125;  */  watch: &#123;    // newVal: 当前最新值    // oldVal: 上一刻值    name(newVal, oldVal)&#123;      console.log(newVal, oldVal);    &#125;,    // 监听引用类型    obj(newVal, oldVal) &#123;      console.log(newVal, oldVal)    &#125;  &#125;&#125;\n\n发现，引用类型的对象无法监听到，该怎么办?\n深度侦听和立即执行\n侦听引用数据类型, 或者立即执行侦听函数\n\n语法：\nwatch: &#123;    &quot;要侦听的属性名&quot;: &#123;        immediate: true, // 立即执行        deep: true, // 深度侦听复杂类型内变化        handler (newVal, oldVal) &#123;                    &#125;    &#125;&#125;\n\n例子：\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;user.age&quot;&gt;&lt;/div&gt;\n\nexport default &#123;  data()&#123;    return &#123;      user: &#123;        name: &quot;&quot;,        age: 0      &#125;    &#125;  &#125;,  // 目标: 侦听对象  /*  语法:    watch: &#123;      变量名 (newVal, oldVal)&#123;        // 变量名对应值改变这里自动触发      &#125;,      变量名: &#123;        handler(newVal, oldVal)&#123;        &#125;,        deep: true, // 深度侦听(对象里面层的值改变)        immediate: true // 立即侦听(网页打开handler执行一次)      &#125;    &#125;  */  watch: &#123;    user: &#123;      handler(newVal, oldVal)&#123;        // user里的对象        console.log(newVal, oldVal);      &#125;,      deep: true,      immediate: true    &#125;  &#125;&#125;\n\n\n总结: immediate立即侦听, deep深度侦听, handler固定方法触发\n\n补充： 另一种监听对象特定属性的方式​        通过设置key为对象属性的索引，value为监听回调方法的形式\nwatch: &#123;   &#x27;user.name&#x27;: (newVal, oldVal) =&gt; &#123;     console.log(newVal, oldVal)   &#125; &#125;\n\nVUE组件为什么要用组件？同样的功能如果要复用的话，以前的方法是直接CV多份，显得代码非常的冗余和重复。\n使用vue提供的单vue文件 - 将某一小块会重复使用的代码封装到单独的vue文件中，以后通过直接使用这个文件来实现功能复用\n概念\n组件是可复用的 VUE 实例, 封装标签(HTML), 样式(CSS)和JS\n\n组件化 ：封装的思想，把页面上 可重用的部分 封装为 组件，从而方便项目的 开发 和 维护\n为什么说工作中写代码就是一个借鉴的过程呢: 一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为(html, css和js)\n\n基础使用\n目标: 每个组件都是一个独立的个体, 代码里体现为一个独立的.vue文件\n\n\n组件内template只能有一个根标签\n组件内data必须是一个函数, 独立作用域\n\n步骤:\n\n创建组件 components/Pannel.vue\n\n封装标签+样式+js - 组件都是独立的, 为了复用\n\n&lt;div&gt;    &lt;div class=&quot;title&quot;&gt;        &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt;        &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt;            &#123;&#123; isShow ? &quot;收起&quot; : &quot;展开&quot; &#125;&#125;        &lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt;        &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt;        &lt;p&gt;平明送客楚山孤。&lt;/p&gt;        &lt;p&gt;洛阳亲友如相问，&lt;/p&gt;        &lt;p&gt;一片冰心在玉壶。&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;\n\nexport default &#123;  data() &#123;    return &#123;      isShow: false,    &#125;;  &#125;,&#125;;\n\n&lt;style scoped&gt;.title &#123;  display: flex;  justify-content: space-between;  align-items: center;  border: 1px solid #ccc;  padding: 0 1em;&#125;.title h4 &#123;  line-height: 2;  margin: 0;&#125;.container &#123;  border: 1px solid #ccc;  padding: 0 1em;&#125;.btn &#123;  /* 鼠标改成手的形状 */  cursor: pointer;&#125;&lt;/style&gt;\n注册组件：创建后需要注册后再使用\n\n全局注册\n全局入口在main.js, 在new Vue之上注册\n// 目标: 全局注册 (一处定义到处使用)// 1. 创建组件 - 文件名.vue// 2. 引入组件import Pannel from &#x27;./components/Pannel&#x27;// 3. 全局 - 注册组件/*  语法:   Vue.component(&quot;组件名&quot;, 组件对象)*/Vue.component(&quot;PannelG&quot;, Pannel)\n\n全局注册PannelG组件名后, 就可以当做标签在任意Vue文件中template里用\n单双标签都可以或者小写加-形式, 运行后, 会把这个自定义标签当做组件解析, 使用\n==组件里封装的标签替换到这个位置==\n以下写法均可：\n&lt;PannelG&gt;&lt;/PannelG&gt;&lt;PannelG/&gt;&lt;pannel-g&gt;&lt;/pannel-g&gt;\n\n注意：\n\n如果组件在全局注册时，启动项目后初始化网页时就会立即加载该组件资源（无论是否在当前页面进行使用），那么这种情况是会导致网页开启缓慢的性能问题的，所以请在往后的开发过程中不要使用全局注册的方式\n关于引用组件的标签写法，这里建议如果import组件时采用的是驼峰命名法拼接的多个单词（如：PannelG），那么在创建标签的时候请用全小写并短横线隔开（如：pannel-g）\n\n\n局部 - 注册使用\n任意需要引用组件的 vue文件中中引入, 注册, 使用\n&lt;div id=&quot;app&quot;&gt;    &lt;h3&gt;案例：折叠面板&lt;/h3&gt;    &lt;!-- 4. 组件名当做标签使用 --&gt;    &lt;!-- &lt;组件名&gt;&lt;/组件名&gt; --&gt;    &lt;PannelG&gt;&lt;/PannelG&gt;    &lt;PannelL&gt;&lt;/PannelL&gt;&lt;/div&gt;\n\n// 目标: 局部注册 (用的多)// 1. 创建组件 - 文件名.vue// 2. 引入组件import Pannel from &#x27;./components/Pannel_1&#x27;export default &#123;    // 3. 局部 - 注册组件    /*        语法:         components: &#123;          &quot;组件名&quot;: 组件对象        &#125;    */    components: &#123;        PannelL: Pannel    &#125;,    /*          当标签名和import引入组件名称相同是可以简写    */    components: &#123;        Pannel    &#125;&#125;\n\n注意： 以后尽量将引入时（import）时的明明与当前注册组件时（components）的命名保持一致\n\n\n\n\n组件使用总结:\n\n(创建)封装html+css+vue到独立的.vue文件中\n(引入注册)组件文件 =&gt; 得到组件配置对象\n(使用)当前页面当做标签使用\n\nCSS中的scoped作用\n作用: 解决多个组件样式名相同, 冲突问题\n\n在style上加入scoped属性, 就会在此组件的标签上加上一个随机生成的data-v-hash开头的属性。保证了必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到\n&lt;style scoped&gt;&lt;/style&gt;\n\n\n解决了组件内部的css样式影响外部文件的问题\n总结: style上加scoped, 组件内的样式只在当前vue组件生效\nvue组件通信父传子 - props步骤：\n\n创建组件 components/MyProduct.vue\n\n&lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: ? &lt;/h3&gt;    &lt;p&gt;价格: ? 元&lt;/p&gt;    &lt;p&gt;描述: ?&lt;/p&gt;&lt;/div&gt;\n\n.my-product &#123;  width: 400px;  padding: 20px;  border: 2px solid #000;  border-radius: 5px;  margin: 10px;&#125;\n\n\n在父组件中注册MyProduct.vue子组件， 在使用时传入具体的数据\n\n&lt;div&gt;  &lt;!--     目标: 父(App.vue) -&gt; 子(MyProduct.vue) 分别传值进入    需求: 每次组件显示不同的数据信息    步骤(口诀):      1. 子组件 - props - 变量 (准备接收)      2. 父组件 - 传值进去   --&gt;  &lt;Product&gt;&lt;/Product&gt;&lt;/div&gt;\n\n// 1. 创建组件 (.vue文件)// 2. 引入组件import Product from &#x27;./components/MyProduct&#x27;export default &#123;  data()&#123;    return &#123;      str: &quot;好贵啊, 快来啊, 好吃&quot;    &#125;  &#125;,  // 3. 注册组件  components: &#123;    // Product: Product // key和value变量名同名 - 简写    Product  &#125;&#125;\n\n\n子组件内在props属性中定义变量, 用于接收外部传入的值\n\n&lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;    &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;  props: [&#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;]&#125;\n\n\n父组件中的组件标签中传入不同的值\n注意: 传入的值，可以是固定值，也可以是变量\n\n\n&lt;div&gt;  &lt;!--     目标: 父(App.vue) -&gt; 子(MyProduct.vue) 分别传值进入    需求: 每次组件显示不同的数据信息    步骤(口诀):      1. 子组件 - props - 变量 (准备接收)      2. 父组件 - 传值进去   --&gt;  &lt;Product title=&quot;好吃的口水鸡&quot; price=&quot;50&quot; intro=&quot;开业大酬宾, 全场8折&quot;&gt;&lt;/Product&gt;  &lt;Product title=&quot;好可爱的可爱多&quot; price=&quot;20&quot; intro=&quot;老板不在家, 全场1折&quot;&gt;&lt;/Product&gt;  &lt;Product title=&quot;好贵的北京烤鸭&quot; price=&quot;290&quot; :intro=&quot;str&quot;&gt;&lt;/Product&gt;&lt;/div&gt;\n\n\n总结： 父传子的流程\n\n子组件内, props定义变量, 在子组件使用变量\n父组件内, 使用子组件, 属性方式给props变量传值\n\n\n要传的数据量较多时，也可以用v-for遍历循环，标签传递\n单项数据流概念： 从父到子的数据流向，叫做单项数据流\n在vue中需要遵循单向数据流原则\n1. 父组件的数据发生了改变，子组件会自动跟着变\n\n2. 子组件不能直接修改父组件传递过来的props  props是只读的\n（这里的只读，是栈内存中的数据只读，可以改堆）\n父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，\n对象是引用类型, 互相更新\n\n&lt;template&gt;  &lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;    &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;() =&gt; &#123;price--&#125;&quot;&gt;宝刀-砍1元&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n出现报错\n\n总结: props的值不能重新赋值, 对象引用关系属性值改变, 互相影响\n子传父 - $emit\n目标： 从子组件把值传出来给外面使用\n\n需求: 实现砍价功能, 子组件点击实现随机砍价-1功能\n语法：\n\n父: @自定义事件名=”父methods函数”\n&lt;MyProduct           v-for=&quot;(obj, i) in list&quot; :key=&quot;obj.id&quot;           :title=&quot;obj.proname&quot;           :price=&quot;obj.proprice&quot;           :intro=&quot;obj.info&quot;           @subprice=&quot;fn&quot;&gt;&lt;/MyProduct&gt;\n\nmethods: &#123;    fn()&#123;        // 逻辑代码 - 修改价格    &#125;&#125;\n子: this.$emit(“自定义事件名”, 传值) - 执行父methods里函数代码\n&lt;div class=&quot;my-product&quot;&gt;  &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;  &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;  &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;  &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt;&lt;/div&gt;\n\nimport eventBus from &#x27;../EventBus&#x27;export default &#123;  props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;],  methods: &#123;    subFn()&#123;      this.$emit(&#x27;subprice&#x27;) // 子向父    &#125;  &#125;&#125;\n如何知道是循环中的那个组件触发的砍价呢？\n\n为循环中的每一个组件设置它在数据列表中的索引号\n\n&lt;MyProduct           v-for=&quot;(obj, i) in list&quot; :key=&quot;obj.id&quot;           :title=&quot;obj.proname&quot;           :price=&quot;obj.proprice&quot;           :intro=&quot;obj.info&quot;           :index=&quot;i&quot;           @subprice=&quot;fn&quot;&gt;&lt;/MyProduct&gt;\n子组件调用父组件方法时，传入当前的索引\nexport default &#123;  props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;],  methods: &#123;    subFn()&#123;      this.$emit(&#x27;subprice&#x27;, this.index) // 子向父    &#125;  &#125;&#125;\n父组件实现砍价的js逻辑\nfn(inde)&#123;    // 逻辑代码    this.list[inde].proprice &gt; 1 &amp;&amp; (this.list[inde].proprice = (this.list[inde].proprice - 1).toFixed(2))&#125;\n\n\n总结: 父自定义事件和方法, 等待子组件触发事件给方法传值\n\n跨组件传参 - EventBus\n如果两个没有任何引入关系的组件，如何进行数据通信？\n\n例如：左侧为组件A，右侧为组件B，左右两侧的组件没人直接关联\n目标：如何听过左侧的砍价，修改右侧的组件中的值\n\n两个组件的关系非常的复杂，通过父子组件通讯是非常麻烦的。这时候可以使用通用的组件通讯方案：事件总线（event-bus)\n\n核心语法：\n\n设置EventBus/index.js- 定义事件总线bus对象\nimport Vue from &#x27;vue&#x27;// 导出空白vue对象export default new Vue()\nList.vue注册事件 - 等待接收要砍价的值 - 准备兄弟页面\n&lt;ul class=&quot;my-product&quot;&gt;    &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt;        &lt;span&gt;&#123;&#123; item.proname &#125;&#125;&lt;/span&gt;        &lt;span&gt;&#123;&#123; item.proprice &#125;&#125;&lt;/span&gt;    &lt;/li&gt;    &lt;li&gt;&#123;&#123;num&#125;&#125;&lt;/li&gt;&lt;/ul&gt;\n\n// 目标: 跨组件传值// 1. 引入空白vue对象(EventBus)// 2. 接收方 - $on监听事件import eventBus from &quot;../EventBus&quot;;export default &#123;    props: [&quot;arr&quot;],    data() &#123;        return &#123;            num: 0        &#125;    &#125;,&#125;;\n\n\n\n.my-product &#123;  width: 400px;  padding: 20px;  border: 2px solid #000;  border-radius: 5px;  margin: 10px;&#125;\ncomponents/MyProduct_sub.vue\n&lt;div class=&quot;my-product&quot;&gt;    &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt;    &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt;&lt;/div&gt;\n\nimport eventBus from &#x27;../EventBus&#x27;export default &#123;  props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;],  methods: &#123;    subFn()&#123;      this.$emit(&#x27;subprice&#x27;, this.index, 1) // 子向父    &#125;  &#125;&#125;\n\n.my-product &#123;  width: 400px;  padding: 20px;  border: 2px solid #000;  border-radius: 5px;  margin: 10px;&#125;\n创建父组件，分别挂载以上两个组件\n\n发现组件A改变数据后，B的数据也会改变，为什么？\n\n&lt;div style=&quot;overflow: hidden;&quot;&gt;    &lt;div style=&quot;float: left;&quot;&gt;        &lt;MyProduct                   v-for=&quot;(obj, i) in list&quot;                   :key=&quot;obj.id&quot;                   :title=&quot;obj.proname&quot;                   :price=&quot;obj.proprice&quot;                   :intro=&quot;obj.info&quot;                   :index=&quot;i&quot;                   @subprice=&quot;fn&quot;                   &gt;&lt;/MyProduct&gt;    &lt;/div&gt;    &lt;div style=&quot;float: left;&quot;&gt;        &lt;List :arr=&quot;list&quot;&gt;&lt;/List&gt;    &lt;/div&gt;&lt;/div&gt;\n\nimport MyProduct from &quot;./components/MyProduct_sub&quot;;import List from &quot;./components/List&quot;;export default &#123;  data() &#123;    return &#123;      list: [        &#123;          id: 1,          proname: &quot;超级好吃的棒棒糖&quot;,          proprice: 18.8,          info: &quot;开业大酬宾, 全场8折&quot;,        &#125;,        &#123;          id: 2,          proname: &quot;超级好吃的大鸡腿&quot;,          proprice: 34.2,          info: &quot;好吃不腻, 快来买啊&quot;,        &#125;,        &#123;          id: 3,          proname: &quot;超级无敌的冰激凌&quot;,          proprice: 14.2,          info: &quot;炎热的夏天, 来个冰激凌了&quot;,        &#125;,      ],    &#125;;  &#125;,  components: &#123;    MyProduct,    List,  &#125;,  methods: &#123;    fn(i, price) &#123;      this.list[i].proprice &gt; 1 &amp;&amp;        (this.list[i].proprice = (this.list[i].proprice - price).toFixed(          2        ));    &#125;,  &#125;,&#125;; \n编写eventBus触发方 - MyProduct_sub.vue\nsubFn()&#123;    this.$emit(&#x27;subprice&#x27;, this.index, 1) // 子向父    eventBus.$emit(&quot;send&quot;, this.index, 1) // 跨组件&#125;\n编写eventBus接收方 - List.vue\n// 3. 组件创建完毕, 监听send事件created() &#123;    eventBus.$on(&quot;send&quot;, (index, price) =&gt; &#123;        this.arr[index].proprice &gt; 1 &amp;&amp;            (this.arr[index].proprice = (this.arr[index].proprice - price).toFixed(2));        this.num++    &#125;);&#125;\n\n\n 总结: eventBus是空的Vue对象, 只负责$on注册事件, $emit触发事件, 一定要确保$on先执行\n\n扩展 props的进阶用法说明：props也可以作为一个对象，并且可以指定数据类型，必要性，默认值\n语法：\nexport default &#123;\tprops: &#123;        a: &#123;            type: String, // 传参类型            required: true, // 是否必传（一般也不写，了解）            default: &#x27;string&#x27; // 默认值        &#125;,        b: &#123;            type: Array,            default: () =&gt; []        &#125;,        c: &#123;            type: Object,            default: () =&gt; (&#123;&#125;)        &#125;    &#125;&#125;;\n\nvue生命周期生命周期\n一个vue组件从 创建 到 销毁 的整个过程就是生命周期\n\n\n钩子函数\n目标: Vue 框架内置函数，随着组件的生命周期阶段，自动执行\n\n作用: 特定的时间点，执行特定的操作\n场景: 组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据\n分类: 4大阶段8个方法\n\n初始化\n挂载\n更新\n销毁\n\n\n\n\n阶段\n方法名\n方法名\n\n\n\n初始化\nbeforeCreate\ncreated\n\n\n挂载\nbeforeMount\nmounted\n\n\n更新\nbeforeUpdate\nupdated\n\n\n销毁\nbeforeDestroy\ndestroyed\n\n\n\n初始化阶段含义讲解:\n1.new Vue() – Vue实例化(组件也是一个小的Vue实例)\n2.Init Events &amp; Lifecycle – 初始化事件和生命周期函数\n3.beforeCreate – 生命周期钩子函数被执行\n4.Init injections&amp;reactivity – Vue内部添加data和methods等\n5.created – 生命周期钩子函数被执行, 实例创建\n6.接下来是编译模板阶段 –开始分析\nmain.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  // el: &quot;#app&quot;, // vue实例编译后的模板挂载到index.html的id叫app的标签上  render: h =&gt; h(App),&#125;).$mount(&quot;#app&quot;)\n\n创建components/Life.vue文件，并且在App.vue里引入\n&lt;div&gt;    &lt;h1&gt;1. 生命周期&lt;/h1&gt;    &lt;Life&gt;&lt;/Life&gt;&lt;/div&gt;\n\nimport Life from &#x27;./components/Life&#x27;export default &#123;  components: &#123;    Life  &#125;&#125;\n\n设置components/Life.vue文件内容\n&lt;div&gt;    &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt;    &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\n\n\nexport default &#123;     data()&#123;         return &#123;             msg: &quot;hello, Vue&quot;,         &#125;     &#125;,     // 一. 初始化     // new Vue()以后, vue内部给实例对象添加了一些属性和方法,     // data和methods初始化&quot;之前&quot;     beforeCreate()&#123;         console.log(&quot;beforeCreate -- 执行&quot;);         console.log(this.msg); // undefined     &#125;     // data和methods初始化以后     // 场景: 网络请求, 注册全局事件     created()&#123;         console.log(&quot;created -- 执行&quot;);         console.log(this.msg); // hello, Vue     &#125; &#125;\n\n\n挂载阶段1.template选项检查\n​    有 - 编译template返回render渲染函数\n​    无 – 编译el选项对应标签作为template(要渲染的模板)（非脚手架）\n2.虚拟DOM挂载成真实DOM之前\n3.beforeMount – 生命周期钩子函数被执行\n4.Create … – 把虚拟DOM和渲染的数据一并挂到真实DOM上\n5.真实DOM挂载完毕\n6.mounted – 生命周期钩子函数被执行\ncomponents/Life.vue 中设置beforeMount和mounted\n&lt;div&gt;    &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt;    &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt;\n\n\n\nexport default &#123;    // ...省略其他代码        // 二. 挂载    // 真实DOM挂载之前    // 场景: 预处理data, 不会触发updated钩子函数    beforeMount()&#123;        console.log(&quot;beforeMount -- 执行&quot;);        console.log(document.getElementById(&quot;myP&quot;)); // null        this.msg = &quot;重新值&quot;    &#125;,    // 真实DOM挂载以后    // 场景: 挂载后真实DOM    mounted()&#123;        console.log(&quot;mounted -- 执行&quot;);        console.log(document.getElementById(&quot;myP&quot;)); // p    &#125;&#125;\n\n\n注意：\n\n一般工作中主要会用到created和mounted这两个生命周期。\n可以在created中修改data中的数据，以及注册全局事件，不可以去查询DOM元素\n可以在mounted中做所有created中可以执行的事件，也可以在这个时期去查询DOM元素\n以上 - 可以直接只用mounted确保万无一失\n\n\n\n更新阶段含义讲解:\n1.当data里数据改变, 更新DOM之前\n2.beforeUpdate – 生命周期钩子函数被执行\n3.Virtual DOM…… – 虚拟DOM重新渲染, 打补丁到真实DOM\n4.updated – 生命周期钩子函数被执行\n5.当有data数据改变 – 重复这个循环\ncomponents/Life.vue 中设置beforeUpdate和updated\n准备ul+li循环, 按钮添加元素, 触发data改变-&gt;导致更新周期开始\n&lt;div&gt;    &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt;    &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;ul id=&quot;myUL&quot;&gt;        &lt;li v-for=&quot;(val, index) in arr&quot; :key=&quot;index&quot;&gt;            &#123;&#123; val &#125;&#125;        &lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;arr.push(1000)&quot;&gt;点击末尾加值&lt;/button&gt;&lt;/div&gt;\n\n\n\nexport default &#123;    data()&#123;        return &#123;            msg: &quot;hello, Vue&quot;,            arr: [5, 8, 2, 1]        &#125;    &#125;,    // ...省略其他代码    // 三. 更新    // 前提: data数据改变才执行    // 更新之前    beforeUpdate() &#123;        console.log(&quot;beforeUpdate -- 执行&quot;);        console.log(document.querySelectorAll(&quot;#myUL&gt;li&quot;)[4]); // undefined    &#125;,    // 更新之后    // 场景: 获取更新后的真实DOM    updated() &#123;        console.log(&quot;updated -- 执行&quot;);        console.log(document.querySelectorAll(&quot;#myUL&gt;li&quot;)[4]); // li    &#125;,&#125;\n\n\n问：\n\n什么时候执行updated钩子函数?\n当数据发生变化并更新页面后\n\n在哪可以获取更新后的DOM?\n在updated钩子函数里\n\n\n注意：\n\n更新阶段有这样一种情景：如果在update更新阶段时对数据做了新的处理，可能又会触发update更新阶段，以此往复会出现修改一次数据触发多次更新阶段逻辑的过程，这样会出现项目代码执行效率低下，在开发过程中，尽量不要去使用update的两个生命周期，如果需要监听某个值的改变应该用到watch！\n\n销毁阶段含义讲解:\n1.当$destroy()被调用 – 比如组件DOM被移除(例v-if)\n2.beforeDestroy – 生命周期钩子函数被执行\n3.拆卸数据监视器、子组件和事件侦听器\n4.实例销毁后, 最后触发一个钩子函数\n5.destroyed – 生命周期钩子函数被执行\ncomponents/Life.vue - 准备生命周期方法(Life组件即将要被删除)\nexport default &#123;    // ...省略其他代码    created() &#123;        // ...省略其他代码        this.timer = setInterval(() =&gt; &#123;            console.log(&quot;哈哈哈&quot;);        &#125;, 1000)    &#125;,        // 四. 销毁    // 前提: v-if=&quot;false&quot; 销毁Vue实例    // 场景: 移除全局事件, 移除当前组件, 计时器, 定时器    beforeDestroy()&#123;        // console.log(&#x27;beforeDestroy -- 执行&#x27;);        clearInterval(this.timer)    &#125;,    destroyed()&#123;        // console.log(&quot;destroyed -- 执行&quot;);    &#125;&#125;\n\nApp.vue - 点击按钮让Life组件从DOM上移除 -&gt; 导致Life组件进入销毁阶段\n&lt;div&gt;  &lt;h1&gt;1. 生命周期&lt;/h1&gt;  &lt;Life v-if=&quot;show&quot;&gt;&lt;/Life&gt;  &lt;button @click=&quot;show = false&quot;&gt;销毁组件&lt;/button&gt;&lt;/div&gt;\n\n\n\nimport Life from &#x27;./components/Life&#x27;export default &#123;    data()&#123;        return &#123;            show: true        &#125;    &#125;,&#125;\n\n注意：\n\n销毁阶段一般是拿来销毁一些全局事件, 移除当前组件, 计时器, 定时器，特别注意！如果子组件中涉及到定时器setInterval时，一定注意当组件销毁时这个定时器是否关闭clearInterval\n\n总结常用的生命周期钩子：\n1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。     2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。 \n关于销毁Vue实例     \n1.销毁后借助Vue开发者工具看不到任何信息。     \n2.销毁后自定义事件会失效，但原生DOM事件依然有效。     \n3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\nVUE实例的方法$refs - 获取DOM元素\n目标: 利用 ref 和 $refs 可以用于获取 dom 元素\n\n步骤：\n\n创建components/More.vue,设置基本结构\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;&lt;/div&gt;\n\n// 目标: 获取组件对象export default &#123;&#125;\nApp.vue引入 组件\n&lt;div&gt;    &lt;h1&gt;1. 生命周期&lt;/h1&gt;    &lt;Life v-if=&quot;show&quot;&gt;&lt;/Life&gt;    &lt;button @click=&quot;show = false&quot;&gt;销毁组件&lt;/button&gt;    &lt;hr&gt;    &lt;h1&gt;2. axios使用&lt;/h1&gt;    &lt;UseAxios&gt;&lt;/UseAxios&gt;    &lt;hr&gt;    &lt;h1&gt;3. $refs的使用&lt;/h1&gt;    &lt;More&gt;&lt;/More&gt;&lt;/div&gt;\n\nimport More from &#x27;./components/More&#x27;export default &#123;    components: &#123;        More    &#125;&#125;\n给标签设置ref属性\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;&lt;/div&gt;\n\n\n\n// 目标: 获取组件对象   // 组件起别名ref   export default &#123;   &#125;\n获取组件对象\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;&lt;/div&gt;\n\n// 目标: 获取组件对象// 组件起别名ref// 恰当时机, 获取组件对象 - mountedexport default &#123;    mounted()&#123;        console.log(document.getElementById(&quot;h&quot;)); // h1        console.log(this.$refs.myH); // h1\t&#125;,&#125;\n\n$refs - 获取组件对象\n通过$refs 可以获取整个组件对象，并且使用该组件中的数据与方法\n\n步骤：\n\n创建components/Child/Demo.vue，组件\n&lt;div&gt;    &lt;p&gt;我是Demo组件&lt;/p&gt;&lt;/div&gt;\n\nexport default &#123;    methods: &#123;        fn()&#123;            console.log(&quot;demo组件内的方法被调用了&quot;);        &#125;    &#125;&#125;\n在More.vue中 - 获取组件对象并设置ref属性\n&lt;div&gt;    &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt;    &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt;    &lt;p&gt;2. 获取组件对象 - 可调用组件内一切&lt;/p&gt;    &lt;Demo ref=&quot;de&quot;&gt;&lt;/Demo&gt;&lt;/div&gt;\n\n// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123;    mounted()&#123;        console.log(document.getElementById(&quot;h&quot;)); // h1        console.log(this.$refs.myH); // h1    &#125;,    components: &#123;        Demo    &#125;&#125;\n使用$refs调用组件中的方法\n// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123;    mounted()&#123;        console.log(document.getElementById(&quot;h&quot;)); // h1        console.log(this.$refs.myH); // h1        let demoObj = this.$refs.de;        demoObj.fn()    &#125;,    components: &#123;        Demo    &#125;&#125;\n\n\n总结: ref定义值, 通过$refs.值 来获取组件对象, 就能继续调用组件内的变量\n\n$nextTick使用\nVue更新DOM-异步的!（数据与页面有延时）\n\n\n案例：点击count++, 马上通过”原生DOM”拿标签内容, 无法拿到新值\n\n步骤：\n\n在 components/Move.vue 中添加以下代码\n&lt;div&gt;    &lt;p&gt;3. vue更新DOM是异步的&lt;/p&gt;    &lt;p ref=&quot;myP&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;btn&quot;&gt;点击count+1, 马上提取p标签内容&lt;/button&gt;&lt;/div&gt;\n\nimport Demo from &#x27;./Child/Demo&#x27;export default &#123;    methods: &#123;        btn()&#123;            this.count++; // vue监测数据更新, 开启一个DOM更新队列(异步任务)            console.log(this.$refs.myP.innerHTML); // 0        &#125;    &#125;&#125;\n\n发现： 页面数据更改了，但从页面上拿到的dom元素中的值还是更改前的数据\n\n使用$nextTick()\n等DOM更新后，触发$nextTick()的函数体执行\n&lt;div&gt;    &lt;p&gt;3. vue更新DOM是异步的&lt;/p&gt;    &lt;p ref=&quot;myP&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;btn&quot;&gt;点击count+1, 马上提取p标签内容&lt;/button&gt;&lt;/div&gt;\n\nimport Demo from &#x27;./Child/Demo&#x27;export default &#123;    methods: &#123;        btn()&#123;            this.count++; // vue监测数据更新, 开启一个DOM更新队列(异步任务)            // console.log(this.$refs.myP.innerHTML); // 0            // 原因: Vue更新DOM异步            // 解决: this.$nextTick()            // 过程: DOM更新完会挨个触发$nextTick里的函数体            this.$nextTick(() =&gt; &#123;                console.log(this.$refs.myP.innerHTML); // 1            &#125;)        &#125;    &#125;&#125;\n\n"}]